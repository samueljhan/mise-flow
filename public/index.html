<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Archives of Us Coffee - Powered by Mise Flow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #2a2a2a;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 1000px;
            width: 100%;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: #1f1f1f;
            color: #e0e0e0;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .header-logo {
            width: 64px;
            height: 64px;
            object-fit: contain;
            flex-shrink: 0;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: none;
            -webkit-user-drag: none;
        }
        
        .header-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
        }

        .header h1 { 
            color: #b0b0b0;
            font-size: 26px;
            font-weight: 600;
            margin: 0;
            line-height: 1.1;
        }

        .header p {
            opacity: 0.7;
            font-size: 13px;
            margin: 0;
            line-height: 1.2;
            color: #909090;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .user-name {
            font-size: 13px;
            color: #e0e0e0;
            font-weight: 500;
        }

        .user-email {
            font-size: 11px;
            color: #888;
        }

        .logout-btn {
            background: #3a3a3a;
            border: none;
            color: #999;
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .logout-btn:hover {
            background: #ff4444;
            color: white;
        }

        .microphone-status {
            padding: 8px 30px;
            background: #242424;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #909090;
        }

        .mic-indicator {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #666;
        }

        .mic-indicator.connected {
            background: #28a745;
            animation: pulse-green 2s infinite;
        }

        .mic-indicator.recording {
            background: #dc3545;
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulse-red {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-bottom: 20px;
            background: #2a2a2a;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user { flex-direction: row-reverse; }

        .message-content {
            max-width: 85%;
            padding: 12px 18px;
            border-radius: 18px;
            line-height: 1.5;
            font-size: 14px;
        }

        .user .message-content {
            background: #3a3a3a;
            color: #e0e0e0;
            border-radius: 18px 18px 4px 18px;
        }

        .assistant .message-content {
            background: #333333;
            color: #d0d0d0;
            border: 1px solid #404040;
            border-radius: 18px 18px 18px 4px;
        }

        .response-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: #404040;
            color: #e0e0e0;
            border: none;
            padding: 7px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .action-btn:hover { background: #505050; }
        .action-btn.success { background: #28a745; }
        .action-btn:disabled, .action-btn.deactivated { 
            background: #2a2a2a !important; 
            color: #555 !important; 
            cursor: not-allowed !important;
            pointer-events: none;
        }

        /* Email Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            border: 1px solid #404040;
        }

        .modal h3 {
            color: #e0e0e0;
            margin-bottom: 16px;
            font-size: 18px;
        }

        .modal input, .modal textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #404040;
            border-radius: 8px;
            background: #333;
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 12px;
            font-family: inherit;
        }

        .modal textarea {
            min-height: 120px;
            resize: vertical;
        }

        .modal input:focus, .modal textarea:focus {
            outline: none;
            border-color: #505050;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .modal-btn.cancel {
            background: #404040;
            color: #e0e0e0;
        }

        .modal-btn.send {
            background: #28a745;
            color: white;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        /* Input container */
        .input-container {
            padding: 15px 20px 20px;
            background: #242424;
            border-top: 1px solid #3a3a3a;
        }

        .input-wrapper {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 28px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: border-color 0.2s;
        }

        .input-wrapper:focus-within {
            border-color: #606060;
        }

        #userInput {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 15px;
            color: #e0e0e0;
            font-family: inherit;
            resize: none;
            outline: none;
            line-height: 24px;
            min-height: 24px;
            max-height: 240px;
            padding: 0;
        }

        #userInput::placeholder {
            color: #707070;
        }

        .voice-btn {
            background: #333333;
            border: 1px solid #404040;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .voice-btn:hover {
            background: #3a3a3a;
            border-color: #505050;
        }

        .voice-btn svg {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: #d0d0d0;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .voice-btn.recording {
            background: #dc3545;
            border-color: #dc3545;
        }

        .voice-btn.recording:hover {
            background: #c82333;
        }

        .voice-btn.recording svg {
            stroke: white;
            animation: pulse-mic 1.5s infinite;
        }

        @keyframes pulse-mic {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #sendBtn {
            background: #333333;
            border: 1px solid #404040;
            color: #d0d0d0;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transition: all 0.3s;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #sendBtn:hover {
            background: #3a3a3a;
            border-color: #505050;
        }

        #sendBtn svg {
            width: 20px;
            height: 20px;
            stroke: #d0d0d0;
            stroke-width: 2.5;
            fill: none;
        }

        .welcome-message {
            text-align: center;
            padding: 60px 20px;
            color: #909090;
        }

        .welcome-message h2 {
            font-size: 22px;
            margin-bottom: 12px;
            color: #b0b0b0;
            font-weight: 500;
        }

        .example-prompts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-top: 25px;
        }

        .example-prompt {
            background: #333333;
            padding: 14px;
            border-radius: 12px;
            border: 1px solid #404040;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .example-prompt:hover {
            border-color: #505050;
            background: #363636;
        }

        .example-prompt strong {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            color: #e0e0e0;
        }

        .example-prompt span {
            font-size: 12px;
            color: #808080;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Prevent body scroll */
        html, body {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            html, body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            .container {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                border-radius: 0;
                height: 100vh;
                height: 100dvh;
                max-width: 100%;
                width: 100%;
                box-shadow: none;
            }
            
            .header {
                border-radius: 0;
                padding: 12px 15px;
            }

            .header-logo {
                width: 50px;
                height: 50px;
            }
            
            .header h1 {
                font-size: 20px;
            }
            
            .header p {
                font-size: 11px;
            }
            
            .microphone-status {
                padding: 5px 15px;
                font-size: 11px;
            }
            
            .chat-container {
                padding: 15px;
            }
            
            .welcome-message {
                padding: 20px 10px;
            }
            
            .welcome-message h2 {
                font-size: 18px;
            }
            
            .example-prompts {
                margin-top: 15px;
                gap: 8px;
                grid-template-columns: 1fr;
            }
            
            .example-prompt {
                padding: 10px;
                height: 60px;
            }
            
            .example-prompt strong {
                font-size: 12px;
            }
            
            .input-container {
                padding: 12px 15px 15px;
            }
            
            .input-wrapper {
                padding: 6px 12px;
            }
            
            #userInput {
                font-size: 14px;
            }
            
            .voice-btn, #sendBtn {
                width: 32px;
                height: 32px;
            }
            
            .voice-btn svg, #sendBtn svg {
                width: 16px;
                height: 16px;
            }
            
            .message-content {
                max-width: 85%;
                font-size: 13px;
                padding: 8px 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="/images/logo.png" alt="Mise Flow Logo" class="header-logo" draggable="false">
            <div class="header-text">
                <h1>Archives of Us Coffee</h1>
                <p>Powered by Mise Flow</p>
            </div>
            <div class="user-profile" id="userProfile">
                <img src="" alt="" class="user-avatar" id="userAvatar" style="display: none;">
                <div class="user-info" id="userInfo" style="display: none;">
                    <span class="user-name" id="userName"></span>
                    <span class="user-email" id="userEmail"></span>
                </div>
                <button class="logout-btn" id="logoutBtn" onclick="logout()" style="display: none;">Logout</button>
            </div>
        </div>

        <div class="microphone-status">
            <div class="mic-indicator" id="micIndicator"></div>
            <span id="micStatus">Ready</span>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="welcome-message">
                <h2>Welcome AOU Coffee</h2>
                <p>What would you like to do right now?</p>
                
                <div class="example-prompts">
                    <div class="example-prompt" onclick="showToDo()">
                        <strong>üìã To Do</strong>
                        <span>View pending tasks and alerts</span>
                    </div>
                    <div class="example-prompt" onclick="checkCurrentInventory()">
                        <strong>‚òï Check Current Inventory</strong>
                        <span>View all coffee stock levels</span>
                    </div>
                    <div class="example-prompt" onclick="openManageInventory()">
                        <strong>üì¶ Manage Inventory</strong>
                        <span>Edit green and roasted coffee</span>
                    </div>
                    <div class="example-prompt" onclick="startRoastOrder()">
                        <strong>üî• Order Roast</strong>
                        <span>Draft a new roast order</span>
                    </div>
                    <div class="example-prompt" onclick="viewEnRoute()">
                        <strong>üöö En Route Coffee</strong>
                        <span>View and manage shipments</span>
                    </div>
                    <div class="example-prompt" onclick="startInvoice()">
                        <strong>üßæ Generate Invoice</strong>
                        <span>Create a wholesale invoice</span>
                    </div>
                    <div class="example-prompt" onclick="manageRetailPlaceholder()">
                        <strong>üõí Manage Retail</strong>
                        <span>Update retail bag sales</span>
                    </div>
                    <div class="example-prompt" onclick="openManageCustomers()">
                        <strong>üë• Manage Customers</strong>
                        <span>View and add customers</span>
                    </div>
                    <div class="example-prompt" onclick="showForecast()">
                        <strong>üìä Forecast</strong>
                        <span>Sales and inventory analytics</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="input-container">
            <div class="input-wrapper">
                <textarea id="userInput" placeholder="Describe what you want to do‚Ä¶" rows="1"></textarea>
                <button class="voice-btn" id="voiceBtn" title="Start recording">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 1a4 4 0 0 1 4 4v7a4 4 0 1 1-8 0V5a4 4 0 0 1 4-4z"/>
                        <path d="M8 11v1a4 4 0 1 0 8 0v-1M12 16v5M8 21h8"/>
                    </svg>
                </button>
                <button id="sendBtn" title="Send message">
                    <svg viewBox="0 0 24 24">
                        <path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.59 5.58L20 12l-8-8z" fill="#d0d0d0" stroke="none"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Email Modal -->
    <div class="modal-overlay" id="emailModal">
        <div class="modal">
            <h3>üìß Create Email Draft</h3>
            <input type="email" id="emailTo" placeholder="Recipient email">
            <input type="text" id="emailSubject" placeholder="Subject" value="Inventory Update">
            <textarea id="emailBody" placeholder="Email content..."></textarea>
            <div id="attachmentIndicator" style="display: none; padding: 10px; margin-bottom: 12px; background: #2d3a2d; border-radius: 8px; color: #90EE90; font-size: 13px;">
                üìé <span id="attachmentName"></span> will be attached
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeEmailModal()">Cancel</button>
                <button class="modal-btn send" id="sendEmailBtn" onclick="sendEmail()">Create Draft</button>
            </div>
        </div>
    </div>

    <!-- Manage Inventory Modal -->
    <div class="modal-overlay" id="inventoryModal">
        <div class="modal" style="max-width: 620px; max-height: 90vh; overflow-y: auto;">
            <h3>Manage Coffee Inventory</h3>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #90EE90; margin-bottom: 10px;">Green Coffee (Unroasted)</h4>
                <div style="color: #666; font-size: 10px; margin-bottom: 8px;">Name | Weight (lb) | Profile | Drop Temp (¬∞F)</div>
                <div id="greenCoffeeList"></div>
                <button class="modal-btn send" onclick="openAddGreenCoffeeModal()" style="margin-top: 10px; width: auto; padding: 8px 16px;">+ Add Green Coffee</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #90EE90; margin-bottom: 10px;">Roasted Coffee</h4>
                <div style="color: #666; font-size: 10px; margin-bottom: 8px;">Name | Weight (lb) | Type (recipe for blends)</div>
                <div id="roastedCoffeeList"></div>
                <button class="modal-btn send" onclick="openAddRoastedCoffeeModal()" style="margin-top: 10px; width: auto; padding: 8px 16px;">+ Add Roasted Coffee</button>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeInventoryModal()">Cancel</button>
                <button class="modal-btn send" onclick="saveInventoryChanges()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Add New Green Coffee Modal -->
    <div class="modal-overlay" id="addGreenCoffeeModal">
        <div class="modal" style="max-width: 450px;">
            <h3>Add New Green Coffee</h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 12px;">Enter details for the new green coffee. Total cost will be used to calculate At-Cost pricing.</p>
            
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Coffee Name</label>
                <input type="text" id="newGreenName" placeholder="e.g., Ethiopia Sidamo" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
            </div>
            
            <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Weight (lb)</label>
                    <input type="number" id="newGreenWeight" placeholder="0" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Total Cost ($)</label>
                    <input type="number" id="newGreenTotalCost" placeholder="0.00" step="0.01" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
            </div>
            
            <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Roast Profile</label>
                    <input type="text" id="newGreenProfile" placeholder="e.g., 122302" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Drop Temp (¬∞F)</label>
                    <input type="text" id="newGreenDropTemp" placeholder="e.g., 410" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
            </div>
            
            <div id="newGreenCostPerLb" style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 15px; display: none;">
                <span style="color: #888; font-size: 12px;">Cost per lb: </span>
                <span id="costPerLbValue" style="color: #90EE90; font-weight: bold;">$0.00</span>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeAddGreenCoffeeModal()">Cancel</button>
                <button class="modal-btn send" onclick="confirmAddGreenCoffee()">Add Coffee</button>
            </div>
        </div>
    </div>

    <!-- Add New Roasted Coffee Modal -->
    <div class="modal-overlay" id="addRoastedCoffeeModal">
        <div class="modal" style="max-width: 500px;">
            <h3>Add New Roasted Coffee</h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 12px;">Enter details for the new roasted coffee. Wholesale pricing will be added to all pricing tables.</p>
            
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Coffee Name</label>
                <input type="text" id="newRoastedName" placeholder="e.g., Ethiopia Sidamo" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;" oninput="updateRoastedPreview()">
            </div>
            
            <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Initial Weight (lb)</label>
                    <input type="number" id="newRoastedWeight" placeholder="0" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Type</label>
                    <select id="newRoastedType" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;" onchange="updateRoastedTypePreview()">
                        <option value="Single Origin">Single Origin</option>
                        <option value="Blend">Blend</option>
                        <option value="Private Label">Private Label</option>
                    </select>
                </div>
            </div>
            
            <div id="newRoastedRecipeInfo" style="background: #2a2a2a; padding: 10px; border-radius: 4px; margin-bottom: 12px;">
                <span style="color: #888; font-size: 12px;">Recipe: </span>
                <span id="newRoastedRecipeText" style="color: #90EE90;">Will use matching green coffee</span>
            </div>
            
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Wholesale Tier 1 Price ($/lb)</label>
                <input type="number" id="newRoastedWholesalePrice" placeholder="e.g., 15.00" step="0.01" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;" oninput="updateRoastedPreview()">
            </div>
            
            <div id="newRoastedPricePreview" style="background: #1a3a1a; padding: 12px; border-radius: 4px; margin-bottom: 15px; display: none;">
                <div style="margin-bottom: 8px;">
                    <span style="color: #888; font-size: 12px;">At-Cost Price: </span>
                    <span id="roastedAtCostPrice" style="color: #f0ad4e;">Loading...</span>
                </div>
                <div style="margin-bottom: 8px;">
                    <span style="color: #888; font-size: 12px;">Wholesale Tier 1: </span>
                    <span id="roastedTier1Price" style="color: #90EE90;">$0.00/lb</span>
                </div>
                <div>
                    <span style="color: #888; font-size: 12px;">Margin: </span>
                    <span id="roastedMargin" style="color: #90EE90;">$0.00/lb</span>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeAddRoastedCoffeeModal()">Cancel</button>
                <button class="modal-btn send" onclick="confirmAddRoastedCoffee()">Add Coffee</button>
            </div>
        </div>
    </div>

    <!-- Manage Wholesale Customers Modal -->
    <div class="modal-overlay" id="manageCustomersModal">
        <div class="modal" style="max-width: 750px; max-height: 90vh; overflow-y: auto;">
            <h3>üë• Wholesale Customers</h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 12px;">Manage wholesale customers and their pricing tables.</p>
            
            <div id="customersList" style="margin-bottom: 20px;">
                <div style="color: #888;">Loading customers...</div>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn send" onclick="openAddCustomerModal()" style="margin-right: auto;">+ Add Customer</button>
                <button class="modal-btn cancel" onclick="closeManageCustomersModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Add New Customer Modal -->
    <div class="modal-overlay" id="addCustomerModal">
        <div class="modal" style="max-width: 550px; max-height: 90vh; overflow-y: auto;">
            <h3>Add New Wholesale Customer</h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 12px;">Create a new wholesale customer with unique invoice code and pricing.</p>
            
            <div style="display: flex; gap: 12px; margin-bottom: 12px;">
                <div style="flex: 2;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Customer Name</label>
                    <input type="text" id="newCustomerName" placeholder="e.g., New Coffee Shop" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                    <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Invoice Code (3 letters)</label>
                    <input type="text" id="newCustomerCode" placeholder="ABC" maxlength="3" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px; text-transform: uppercase;" oninput="validateCustomerCode()">
                    <div id="codeValidation" style="font-size: 11px; margin-top: 4px; color: #888;"></div>
                </div>
            </div>
            
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Email Address(es)</label>
                <input type="text" id="newCustomerEmails" placeholder="email@example.com, email2@example.com" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                <div style="font-size: 10px; color: #666; margin-top: 4px;">Separate multiple emails with commas</div>
            </div>
            
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Pricing</label>
                <select id="newCustomerPricingType" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 8px;" onchange="updatePricingTypeUI()">
                    <option value="existing">Link to Existing Pricing Table</option>
                    <option value="custom">Create Custom Pricing</option>
                </select>
            </div>
            
            <div id="existingPricingSection">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Select Pricing Table</label>
                <select id="newCustomerPricingTable" style="width: 100%; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;">
                    <option value="tier1">Wholesale Tier 1</option>
                    <option value="dex">Wholesale Dex</option>
                    <option value="ced">Wholesale CED</option>
                    <option value="junia">Wholesale Junia</option>
                </select>
            </div>
            
            <div id="customPricingSection" style="display: none;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Price Ratio vs Tier 1</label>
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                    <input type="number" id="newCustomerPriceRatio" placeholder="0.95" step="0.01" min="0.5" max="1.5" value="1.00" style="width: 100px; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 4px;" oninput="updateCustomPricingPreview()">
                    <span style="color: #888; font-size: 12px;">√ó Tier 1 prices</span>
                </div>
                <div id="customPricingPreview" style="background: #2a2a2a; padding: 10px; border-radius: 4px; font-size: 12px; color: #888;">
                    Enter a ratio to see price examples
                </div>
            </div>
            
            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="modal-btn cancel" onclick="closeAddCustomerModal()">Cancel</button>
                <button class="modal-btn send" onclick="confirmAddCustomer()">Add Customer</button>
            </div>
        </div>
    </div>

    <!-- Roast Order Configuration Modal -->
    <div class="modal-overlay" id="roastOrderModal">
        <div class="modal" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <h3>üî• Configure Roast Order</h3>
            <p style="color: #888; margin-bottom: 15px;">Adjust batch sizes and weights for each coffee:</p>
            
            <div id="roastOrderConfig"></div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeRoastOrderModal()">Cancel</button>
                <button class="modal-btn send" onclick="generateRoastOrderEmail()">Generate Email</button>
            </div>
        </div>
    </div>

    <!-- Invoice Reminder Modal -->
    <div class="modal-overlay" id="invoiceReminderModal">
        <div class="modal" style="max-width: 600px;">
            <h3>Invoice Reminder Email</h3>
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">To</label>
                <input type="email" id="reminderEmailTo" placeholder="Recipient email" style="width: 100%;">
            </div>
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Subject</label>
                <input type="text" id="reminderEmailSubject" placeholder="Subject" style="width: 100%;">
            </div>
            <div style="margin-bottom: 12px;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Message</label>
                <textarea id="reminderEmailBody" style="min-height: 250px; width: 100%;"></textarea>
            </div>
            <div style="color: #90EE90; font-size: 12px; margin-bottom: 12px; padding: 8px; background: #2a3a2a; border-radius: 4px;">
                Invoice PDFs will be attached automatically
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeInvoiceReminderModal()">Cancel</button>
                <button class="modal-btn send" onclick="confirmInvoiceReminder()">Create Draft</button>
            </div>
        </div>
    </div>

    <!-- Roast Order Email Preview Modal -->
    <div class="modal-overlay" id="roastEmailModal">
        <div class="modal" style="max-width: 600px;">
            <h3>üìß Roast Order Email Preview</h3>
            <input type="email" id="roastEmailTo" placeholder="Recipient email" value="samueljhan@gmail.com">
            <input type="text" id="roastEmailSubject" placeholder="Subject">
            <textarea id="roastEmailBody" style="min-height: 300px;"></textarea>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeRoastEmailModal()">Back</button>
                <button class="modal-btn send" onclick="confirmRoastOrderWithCopy()">Copy Email</button>
            </div>
        </div>
    </div>

    <!-- En Route Coffee Modal -->
    <div class="modal-overlay" id="enRouteModal">
        <div class="modal" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <h3>üöö En Route Coffee</h3>
            <p style="color: #888; margin-bottom: 15px;">Coffee orders that have been placed but not yet received:</p>
            
            <div id="enRouteList"></div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeEnRouteModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Roast Order Modal -->
    <div class="modal-overlay" id="editOrderModal">
        <div class="modal" style="max-width: 450px; max-height: 85vh; overflow-y: auto;">
            <h3>Edit Roast Order</h3>
            <p style="color: #888; margin-bottom: 15px;">Adjust the roasted coffee amounts:</p>
            
            <div id="editOrderList"></div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeEditOrderModal()">Cancel</button>
                <button class="modal-btn send" onclick="applyOrderEdits()">Apply Changes</button>
            </div>
        </div>
    </div>

    <!-- Customize Blend Modal -->
    <div class="modal-overlay" id="customizeBlendModal">
        <div class="modal" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <h3>Customize Blend</h3>
            <p style="color: #888; margin-bottom: 15px;">Adjust green coffee ratios and add components:</p>
            
            <div id="customizeBlendList"></div>
            <div id="inventoryWarnings" style="margin-top: 12px;"></div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeCustomizeBlendModal()">Cancel</button>
                <button class="modal-btn send" onclick="applyBlendCustomization()">Apply Changes</button>
            </div>
        </div>
    </div>

    <!-- Tracking Entry Modal -->
    <div class="modal-overlay" id="trackingModal">
        <div class="modal" style="max-width: 500px; max-height: 85vh; overflow-y: auto;">
            <h3>Enter Tracking Numbers</h3>
            <p style="color: #888; margin-bottom: 15px;">Add tracking numbers for en route orders:</p>
            
            <div id="trackingOrderList"></div>
            
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeTrackingModal()">Cancel</button>
                <button class="modal-btn send" onclick="saveAllTracking()">Save All</button>
            </div>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const micIndicator = document.getElementById('micIndicator');
        const micStatus = document.getElementById('micStatus');
        
        let ws = null;
        let audioContext = null;
        let mediaStream = null;
        let processor = null;
        let isRecording = false;
        let googleConnected = false;
        let currentResponseText = '';
        let partialTranscript = '';
        let savedTextBeforePartial = '';
        let currentUser = null;
        
        // Inventory state
        let greenCoffeeInventory = [];
        let roastedCoffeeInventory = [];
        let enRouteCoffeeInventory = [];
        let pendingRoastOrder = [];
        let pendingRoastEmail = null;
        let waitingForRoastOrder = false;

        // Check user authentication and Google status on load
        async function checkAuthAndGoogleStatus() {
            try {
                // Check if user is authenticated
                const userResponse = await fetch('/api/user');
                if (userResponse.status === 401) {
                    // Not authenticated, redirect to login
                    window.location.href = '/login';
                    return;
                }
                const userData = await userResponse.json();
                if (userData.authenticated && userData.user) {
                    currentUser = userData.user;
                    updateUserUI();
                }

                // Check Google status
                const response = await fetch('/api/google/status');
                const data = await response.json();
                googleConnected = data.connected;
            } catch (error) {
                console.error('Error checking auth status:', error);
                // If error, might be auth issue - redirect to login
                window.location.href = '/login';
            }
        }

        function updateUserUI() {
            if (currentUser) {
                const avatarEl = document.getElementById('userAvatar');
                const nameEl = document.getElementById('userName');
                const emailEl = document.getElementById('userEmail');
                const infoEl = document.getElementById('userInfo');
                const logoutBtn = document.getElementById('logoutBtn');

                if (currentUser.picture) {
                    avatarEl.src = currentUser.picture;
                    avatarEl.style.display = 'block';
                }
                if (currentUser.name) {
                    nameEl.textContent = currentUser.name;
                    infoEl.style.display = 'flex';
                }
                if (currentUser.email) {
                    emailEl.textContent = currentUser.email;
                }
                logoutBtn.style.display = 'block';
            }
        }

        // Call this when we get a 401 to redirect to login
        function handleAuthError() {
            window.location.href = '/login';
        }

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                window.location.href = '/logout';
            }
        }

        // Wrapper for API calls that handles 401
        async function authenticatedFetch(url, options = {}) {
            const response = await fetch(url, options);
            if (response.status === 401) {
                handleAuthError();
                throw new Error('Authentication required');
            }
            return response;
        }

        // Check auth on page load
        checkAuthAndGoogleStatus();

        // Function to connect Google while preserving state
        function connectGoogle(returnAction) {
            // Save the action to restore after OAuth
            if (returnAction) {
                localStorage.setItem('miseflow_pending_action', returnAction);
            }
            window.location.href = '/auth/google';
        }

        // Check URL params for connection status
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('google') === 'connected') {
            googleConnected = true;
            window.history.replaceState({}, document.title, window.location.pathname);
            
            // Check if there's a pending action to restore
            const pendingAction = localStorage.getItem('miseflow_pending_action');
            if (pendingAction) {
                localStorage.removeItem('miseflow_pending_action');
                // Restore the action after a short delay to let UI initialize
                setTimeout(() => {
                    if (pendingAction === 'invoice') {
                        startInvoice();
                    } else if (pendingAction === 'roast_order') {
                        startRoastOrder();
                    } else if (pendingAction === 'email') {
                        // Just show a message that they can now send emails
                        addMessage('Google connected! You can now send emails.', false);
                        addFollowUpButtons();
                    }
                }, 300);
            }
        }

        // Auto-resize textarea
        userInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 240) + 'px';
        });

        function useExample(element) {
            const text = element.querySelector('span').textContent.replace(/['"]/g, '');
            userInput.value = text;
            userInput.style.height = 'auto';
            userInput.style.height = userInput.scrollHeight + 'px';
            userInput.focus();
        }

        let pendingInvoice = false;

        function startInvoice() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();

            // Check if Google is connected first
            if (!googleConnected) {
                addMessage(`<div style="color: #dc3545;">‚ö†Ô∏è Google account not connected</div>
                    <div style="margin-top: 8px;">Invoice generation requires a connected Google account to create PDFs and access pricing data.</div>
                    <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('invoice')">Connect Google Account</button>`, false);
                return;
            }

            // Add assistant message asking for details
            addMessage('<strong>Generate Invoice</strong><br><br>Customer and order details?<br><br><em style="color:#707070;">Example: "CED, 100 lbs Archives Blend"</em>', false);
            
            // Set flag for next message
            pendingInvoice = true;
            userInput.placeholder = 'Enter customer name, quantity, and product...';
            userInput.focus();
        }

        // ============ Coffee Inventory Functions ============

        // Load inventory from server
        async function loadInventory() {
            try {
                const response = await fetch('/api/inventory');
                const data = await response.json();
                greenCoffeeInventory = data.green || [];
                roastedCoffeeInventory = data.roasted || [];
                enRouteCoffeeInventory = data.enRoute || [];
            } catch (error) {
                console.error('Error loading inventory:', error);
            }
        }

        // Typing effect helper
        async function typeText(element, text, speed = 15) {
            return new Promise((resolve) => {
                let i = 0;
                element.innerHTML = '';
                
                function type() {
                    if (i < text.length) {
                        // Handle HTML tags - add them all at once
                        if (text[i] === '<') {
                            const closeIndex = text.indexOf('>', i);
                            if (closeIndex !== -1) {
                                element.innerHTML += text.substring(i, closeIndex + 1);
                                i = closeIndex + 1;
                            } else {
                                element.innerHTML += text[i];
                                i++;
                            }
                        } else {
                            element.innerHTML += text[i];
                            i++;
                        }
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        setTimeout(type, speed);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }

        // Check Current Inventory button
        async function checkCurrentInventory() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();

            addMessage('Checking current coffee inventory...', false);
            
            try {
                // Fetch full inventory data
                const invResponse = await fetch('/api/inventory');
                const inv = await invResponse.json();
                
                // Handle error response
                if (inv.error) {
                    throw new Error(inv.error);
                }
                
                // Ensure arrays exist
                const green = inv.green || [];
                const roasted = inv.roasted || [];
                const enRoute = inv.enRoute || [];
                
                greenCoffeeInventory = green;
                roastedCoffeeInventory = roasted;
                enRouteCoffeeInventory = enRoute;
                
                // Build the summary text - clean and simple
                let summary = 'Current Coffee Inventory\n\n';
                
                summary += 'GREEN COFFEE\n';
                if (green.length > 0) {
                    green.forEach(coffee => {
                        summary += `   ${coffee.name} ‚Äî ${coffee.weight} lb\n`;
                    });
                } else {
                    summary += '   None\n';
                }
                
                summary += '\nROASTED COFFEE\n';
                if (roasted.length > 0) {
                    roasted.forEach(coffee => {
                        summary += `   ${coffee.name} ‚Äî ${coffee.weight} lb\n`;
                    });
                } else {
                    summary += '   None\n';
                }
                
                summary += '\nEN ROUTE\n';
                if (enRoute.length > 0) {
                    enRoute.forEach(coffee => {
                        summary += `   ${coffee.name} ‚Äî ${coffee.weight} lb\n`;
                    });
                } else {
                    summary += '   None\n';
                }
                
                // Get the last message and type into it
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.style.whiteSpace = 'pre-wrap';
                    content.style.fontFamily = 'monospace';
                    await typeText(content, summary, 8);
                }
                
                // Add follow-up suggestions
                setTimeout(() => {
                    addConversationalFollowUp('inventory_checked');
                }, 300);
                
            } catch (error) {
                console.error('Error:', error);
                addMessage('Error loading inventory: ' + error.message, false);
            }
        }

        // Start Roast Order
        function startRoastOrder() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();

            // Clear any previous clarification context
            window.pendingClarification = null;

            addMessage('Which coffee roasts do you want to order?<br><br><em style="color:#707070;">Example: "Archives Blend" or "Ethiopia Gera"</em>', false);
            
            waitingForRoastOrder = true;
            userInput.placeholder = 'Enter coffee roasts to order...';
            userInput.focus();
        }

        // Parse roast order response
        async function parseRoastOrder(userText) {
            try {
                addMessage('Analyzing your order...', false);
                
                // Build request with context if we had a previous clarification
                const requestBody = { userInput: userText };
                if (window.pendingClarification) {
                    requestBody.previousQuestion = window.pendingClarification.question;
                    requestBody.previousSuggestion = window.pendingClarification.suggestion;
                }
                
                const response = await fetch('/api/roast-order/parse', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                // Clear previous clarification context
                window.pendingClarification = null;
                
                if (data.needsClarification) {
                    // Store clarification context for next response
                    window.pendingClarification = {
                        question: data.clarificationQuestion,
                        suggestion: data.suggestedCoffee
                    };
                    
                    // Update last message with clarification question
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = data.clarificationQuestion;
                    }
                    waitingForRoastOrder = true;
                    return;
                }
                
                if (data.understood && data.coffees && data.coffees.length > 0) {
                    const matchedCoffees = data.coffees.filter(c => c.matched);
                    if (matchedCoffees.length === 0) {
                        const messages = chatContainer.querySelectorAll('.message');
                        const lastMsg = messages[messages.length - 1];
                        if (lastMsg) {
                            const content = lastMsg.querySelector('.message-content') || lastMsg;
                            content.innerHTML = 'Could not find any matching coffees. Please specify exact names from our roasted coffee list.';
                        }
                        waitingForRoastOrder = true;
                        return;
                    }
                    
                    // Build default order based on coffee types
                    pendingRoastOrder = matchedCoffees.map(c => {
                        const roasted = roastedCoffeeInventory.find(r => r.name === c.name);
                        const nameLower = c.name.toLowerCase();
                        
                        // Archives Blend - default to full batches: 2x65lb Brazil + 1x65lb Yirg = 195lb green ‚Üí 165lb roasted
                        if (nameLower.includes('archives') || nameLower.includes('blend')) {
                            return {
                                name: c.name,
                                type: 'Blend',
                                recipe: roasted?.recipe || [
                                    { greenCoffeeId: 'brazil-mogiano', name: 'Brazil Mogiano', percentage: 66.6667 },
                                    { greenCoffeeId: 'ethiopia-yirgacheffe', name: 'Ethiopia Yirgacheffe', percentage: 33.3333 }
                                ],
                                weight: 165  // Full batches: 195lb green * 0.85 = 165lb roasted
                            };
                        }
                        // Ethiopia Gera - default 55lb  
                        else if (nameLower.includes('ethiopia') && nameLower.includes('gera')) {
                            return {
                                name: c.name,
                                type: 'Single Origin',
                                recipe: roasted?.recipe || [
                                    { greenCoffeeId: 'ethiopia-gera-58484', name: 'Ethiopia Gera 58484', percentage: 50 },
                                    { greenCoffeeId: 'ethiopia-gera-58479', name: 'Ethiopia Gera 58479', percentage: 50 }
                                ],
                                weight: 55
                            };
                        }
                        // Colombia Excelso - Single Origin
                        else if (nameLower.includes('colombia') && !nameLower.includes('decaf')) {
                            return {
                                name: c.name,
                                type: 'Single Origin',
                                recipe: roasted?.recipe || [
                                    { greenCoffeeId: 'colombia-antioquia', name: 'Colombia Antioquia', percentage: 100 }
                                ],
                                weight: 55
                            };
                        }
                        // Decaf or other Private Label
                        else {
                            return {
                                name: c.name,
                                type: roasted?.type || 'Private Label',
                                recipe: null,
                                weight: 20
                            };
                        }
                    });
                    
                    // Show default order in chat
                    showDefaultOrderInChat();
                } else {
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = 'Could not understand the order. Please try again with specific coffee names.';
                    }
                    waitingForRoastOrder = true;
                }
            } catch (error) {
                console.error('Error parsing order:', error);
                addMessage('Error: ' + error.message, false);
                waitingForRoastOrder = true;
            }
        }

        // Show default order in chat
        function showDefaultOrderInChat() {
            // Helper to calculate batches
            // For defaults: use full 65lb batches to maximize batch weights
            // For user adjustments: distribute weight evenly across batches (25-65lb range)
            const calcBatches = (totalWeight, forceMax = false) => {
                const batches = Math.ceil(totalWeight / 65);
                if (forceMax) {
                    // For default orders, use max 65lb batches
                    return { batches, batchWeight: 65 };
                }
                // For user-specified weights, distribute evenly
                if (totalWeight <= 65) {
                    return { batches: 1, batchWeight: Math.round(totalWeight) };
                }
                const batchWeight = Math.round(totalWeight / batches);
                return { batches, batchWeight };
            };
            
            let html = '<strong>Order Summary:</strong><br><br>';
            let hasValidationError = false;
            
            pendingRoastOrder.forEach((item, index) => {
                if (item.name === 'Archives Blend' && item.recipe) {
                    // Archives Blend: Brazil batches blended with Yirgacheffe batches
                    const totalGreenWeight = Math.round(item.weight / 0.85);
                    
                    const brazilComp = item.recipe.find(r => r.name.includes('Brazil'));
                    const yirgComp = item.recipe.find(r => r.name.includes('Yirgacheffe'));
                    
                    const brazilGreen = greenCoffeeInventory.find(g => g.id === 'brazil-mogiano');
                    const yirgGreen = greenCoffeeInventory.find(g => g.id === 'ethiopia-yirgacheffe');
                    
                    const brazilWeightNeeded = Math.round(totalGreenWeight * (brazilComp?.percentage || 66.67) / 100);
                    const yirgWeightNeeded = Math.round(totalGreenWeight * (yirgComp?.percentage || 33.33) / 100);
                    
                    const brazilBatch = calcBatches(brazilWeightNeeded);
                    const yirgBatch = calcBatches(yirgWeightNeeded);
                    
                    // Validate batch weights
                    if (brazilBatch.batchWeight < 25) hasValidationError = true;
                    if (yirgBatch.batchWeight < 25) hasValidationError = true;
                    
                    // Use user's entered weight, not recalculated
                    html += `<strong>Archives Blend</strong> (~${Math.round(item.weight)}lb roasted):<br>`;
                    html += `<div style="margin-left: 8px;">`;
                    html += `- ${brazilBatch.batches} batch${brazilBatch.batches > 1 ? 'es' : ''} of Brazil Mogiano (${brazilBatch.batchWeight}lb - profile ${brazilGreen?.roastProfile || '199503'} - drop temp ${brazilGreen?.dropTemp || 419})<br>`;
                    html += `<span style="margin-left: 4px;">blended with</span><br>`;
                    html += `- ${yirgBatch.batches} batch${yirgBatch.batches > 1 ? 'es' : ''} of Ethiopia Yirgacheffe (${yirgBatch.batchWeight}lb - profile ${yirgGreen?.roastProfile || '141402'} - drop temp ${yirgGreen?.dropTemp || 415})`;
                    html += `</div><br><br>`;
                    
                } else if (item.name === 'Ethiopia Gera') {
                    // Ethiopia Gera: Special 50/50 split between two lots per batch
                    // Default batch is 65lb, split into 33lb + 33lb (round UP both - exception to max)
                    const totalGreenWeight = Math.round(item.weight / 0.85);
                    const { batches, batchWeight } = calcBatches(totalGreenWeight);
                    const halfBatchWeight = Math.ceil(batchWeight / 2); // Round UP to 33lb each
                    
                    // Find either lot to get roast profile
                    const geraGreen = greenCoffeeInventory.find(g => g.id === 'ethiopia-gera-58484' || g.id === 'ethiopia-gera-58479' || g.id === 'ethiopia-gera');
                    const profile = geraGreen?.roastProfile || '061901';
                    const dropTemp = geraGreen?.dropTemp || 414;
                    
                    // Validate batch weight
                    if (batchWeight < 25) hasValidationError = true;
                    
                    // Use user's entered weight, not recalculated
                    html += `<strong>Ethiopia Gera</strong> (~${Math.round(item.weight)}lb roasted):<br>`;
                    html += `<div style="margin-left: 8px;">`;
                    html += `- ${batches} batch${batches > 1 ? 'es' : ''} of Ethiopia Gera (${halfBatchWeight}lb lot 58484 + ${halfBatchWeight}lb lot 58479 - profile ${profile} - drop temp ${dropTemp})`;
                    html += `</div><br><br>`;
                    
                } else if (item.type === 'Single Origin' && item.recipe) {
                    // Other single origins - default 65lb batches
                    const green = greenCoffeeInventory.find(g => g.id === item.recipe[0].greenCoffeeId);
                    const greenWeight = Math.round(item.weight / 0.85);
                    const { batches, batchWeight } = calcBatches(greenWeight);
                    
                    // Validate batch weight
                    if (batchWeight < 25) hasValidationError = true;
                    
                    // Use user's entered weight, not recalculated
                    html += `<strong>${item.name}</strong> (~${Math.round(item.weight)}lb roasted):<br>`;
                    html += `<div style="margin-left: 8px;">`;
                    html += `- ${batches} batch${batches > 1 ? 'es' : ''} of ${item.name} (${batchWeight}lb - profile ${green?.roastProfile || '?'} - drop temp ${green?.dropTemp || '?'})`;
                    html += `</div><br><br>`;
                    
                } else if (item.type === 'Private Label') {
                    // Private Label - output = input (comes roasted)
                    html += `<strong>${item.name}</strong>:<br>`;
                    html += `<div style="margin-left: 8px;">`;
                    html += `- ${Math.round(item.weight)}lb private label`;
                    html += `</div><br><br>`;
                    
                } else if (item.type === 'Blend' && item.recipe) {
                    // Generic blend fallback
                    const totalGreenWeight = Math.round(item.weight / 0.85);
                    
                    let blendLines = [];
                    
                    item.recipe.forEach((comp, idx) => {
                        const green = greenCoffeeInventory.find(g => g.id === comp.greenCoffeeId);
                        const compGreenWeight = Math.round(totalGreenWeight * comp.percentage / 100);
                        const { batches, batchWeight } = calcBatches(compGreenWeight);
                        
                        if (batchWeight < 25) hasValidationError = true;
                        
                        blendLines.push(`- ${batches} batch${batches > 1 ? 'es' : ''} of ${comp.name} (${batchWeight}lb - profile ${green?.roastProfile || '?'} - drop temp ${green?.dropTemp || '?'})`);
                    });
                    
                    // Use user's entered weight, not recalculated
                    html += `<strong>${item.name}</strong> (~${Math.round(item.weight)}lb roasted):<br>`;
                    html += `<div style="margin-left: 8px;">`;
                    html += blendLines.join('<br><span style="margin-left: 4px;">blended with</span><br>');
                    html += `</div><br><br>`;
                }
            });
            
            if (hasValidationError) {
                html += '<div style="background:#4a3030; padding:10px; border-radius:8px; margin-bottom:12px;">';
                html += '<strong>Batch size issue:</strong> Each batch must be between 25-65lb. ';
                html += 'Please adjust your order weight. <em>Tip: Max out at 65lb batches to save costs!</em>';
                html += '</div>';
            }
            
            html += '<div style="color:#888; font-size:12px; margin-bottom:12px;">*Using max 65lb batches minimizes roasting costs</div>';
            html += '<div class="response-buttons" style="margin-top: 12px;">';
            html += '<button class="action-btn" onclick="confirmDefaultOrder()">Confirm</button>';
            html += '<button class="action-btn" onclick="openEditOrderModal()">Edit Order</button>';
            html += '<button class="action-btn" onclick="openCustomizeBlendModal()">Customize Blend</button>';
            html += '<button class="action-btn" onclick="cancelRoastOrder()">Cancel</button>';
            html += '</div>';
            
            // Update last message
            const messages = chatContainer.querySelectorAll('.message');
            const lastMsg = messages[messages.length - 1];
            if (lastMsg) {
                const content = lastMsg.querySelector('.message-content') || lastMsg;
                content.innerHTML = html;
            }
            
            window.waitingForOrderConfirmation = true;
        }

        // Confirm default order and generate email
        async function confirmDefaultOrder() {
            window.waitingForOrderConfirmation = false;
            addMessage('Confirmed', true);
            addMessage('Generating email draft...', false);
            
            try {
                const response = await fetch('/api/roast-order/generate-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orderItems: pendingRoastOrder })
                });
                
                const data = await response.json();
                pendingRoastEmail = data;
                
                // Show email preview in chat
                let html = '<strong>Email Preview</strong><br><br>';
                html += `<strong>To:</strong> ${data.to}<br>`;
                html += `<strong>Subject:</strong> ${data.subject}<br><br>`;
                html += `<div style="background:#1a1a1a; padding:12px; border-radius:8px; white-space:pre-wrap; font-size:13px;">${data.body}</div><br>`;
                html += '<div class="response-buttons" style="margin-top: 12px;">';
                html += '<button class="action-btn" onclick="copyRoastEmail()">Copy Email</button>';
                html += '<button class="action-btn" onclick="editRoastEmail()">Edit Email</button>';
                html += '<button class="action-btn" onclick="cancelRoastOrder()">Cancel</button>';
                html += '</div>';
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = html;
                }
                
            } catch (error) {
                console.error('Error generating email:', error);
                addMessage('Error generating email: ' + error.message, false);
            }
        }

        // Edit email in modal
        function editRoastEmail() {
            if (!pendingRoastEmail) return;
            document.getElementById('roastEmailTo').value = pendingRoastEmail.to;
            document.getElementById('roastEmailSubject').value = pendingRoastEmail.subject;
            document.getElementById('roastEmailBody').value = pendingRoastEmail.body;
            document.getElementById('roastEmailModal').style.display = 'flex';
        }

        // Confirm from chat
        async function confirmRoastOrderFromChat() {
            if (!pendingRoastEmail) return;
            
            const emailData = {
                to: pendingRoastEmail.to,
                subject: pendingRoastEmail.subject,
                body: pendingRoastEmail.body
            };
            
            await finalizeRoastOrder(emailData);
        }

        // Copy email to clipboard
        async function copyRoastEmail() {
            if (!pendingRoastEmail) return;
            
            addMessage('Validating inventory and updating...', false);
            
            try {
                // First, update inventory and en route
                const response = await fetch('/api/roast-order/confirm-no-draft', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderItems: pendingRoastOrder
                    })
                });
                
                const data = await response.json();
                
                // Check for inventory shortage
                if (data.success === false) {
                    let errorHtml = '<strong style="color: #ff6b6b;">Order Cannot Be Confirmed</strong><br><br>';
                    errorHtml += `<div style="color: #ff6b6b; margin-bottom: 12px;">${data.message}</div>`;
                    
                    if (data.shortages && data.shortages.length > 0) {
                        errorHtml += '<div style="margin-bottom: 12px;">Shortages:</div>';
                        data.shortages.forEach(s => {
                            errorHtml += `<div style="color: #ff6b6b;">‚Ä¢ ${s.name}: need ${s.required}lb, only ${s.available}lb available</div>`;
                        });
                    }
                    
                    errorHtml += '<br><div>Please reduce the order quantities or add more green coffee inventory.</div>';
                    
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = errorHtml;
                    }
                    return;
                }
                
                // Only copy email if inventory update succeeded
                const emailText = `To: ${pendingRoastEmail.to}\nSubject: ${pendingRoastEmail.subject}\n\n${pendingRoastEmail.body}`;
                await navigator.clipboard.writeText(emailText);
                
                // Show confirmation message
                let confirmHtml = '<strong>Order Confirmed & Email Copied</strong><br><br>';
                confirmHtml += '<div style="color: #90EE90; margin-bottom: 12px;">‚úì Email copied - paste into your email client</div>';
                
                if (data.deductions && data.deductions.length > 0) {
                    confirmHtml += 'Green coffee inventory updated:<br>';
                    data.deductions.forEach(d => {
                        confirmHtml += `   ${d.name}: -${d.deducted}lb (${d.remaining}lb remaining)<br>`;
                    });
                    confirmHtml += '<br>';
                }
                
                confirmHtml += `Added ${data.enRouteItems?.length || 0} item(s) to en route.`;
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = confirmHtml;
                }
                
                // Reload inventory
                await loadInventory();
                
                // Reset state
                pendingRoastOrder = [];
                pendingRoastEmail = null;
                waitingForRoastOrder = false;
                window.waitingForOrderConfirmation = false;
                userInput.placeholder = 'Describe what you want to do‚Ä¶';
                
                // Add conversational follow-up
                addConversationalFollowUp('roast_order_confirmed');
                
            } catch (error) {
                console.error('Error copying email:', error);
                addMessage('Error: ' + error.message, false);
            }
        }

        // Cancel roast order
        function cancelRoastOrder() {
            pendingRoastOrder = [];
            pendingRoastEmail = null;
            waitingForRoastOrder = false;
            window.waitingForOrderConfirmation = false;
            window.pendingClarification = null;
            addMessage('Order cancelled.', false);
            userInput.placeholder = 'Describe what you want to do‚Ä¶';
            addConversationalFollowUp('order_cancelled');
        }

        // Modify roast order based on user input
        async function modifyRoastOrder(userRequest) {
            addMessage('Updating order...', false);
            
            try {
                const response = await fetch('/api/roast-order/modify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userRequest,
                        currentOrder: pendingRoastOrder
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.orderItems) {
                    pendingRoastOrder = data.orderItems;
                    
                    // Update last message with new order summary
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = data.summary;
                    }
                    
                    window.waitingForOrderConfirmation = true;
                } else {
                    // Show clarification message but keep in order mode
                    const clarificationMsg = data.message || "How much of each coffee would you like? For example: '80lb Archives Blend and 60lb Ethiopia Gera'";
                    
                    // Build a response that keeps order context
                    let html = `<div style="margin-bottom:12px;">${clarificationMsg}</div>`;
                    html += '<div style="color:#888; font-size:12px; margin-bottom:12px;">Current order: ';
                    html += pendingRoastOrder.map(o => `${o.weight}lb ${o.name}`).join(', ');
                    html += '</div>';
                    html += '<div class="response-buttons" style="margin-top: 12px;">';
                    html += '<button class="action-btn" onclick="openEditOrderModal()">Edit Order</button>';
                    html += '<button class="action-btn" onclick="cancelRoastOrder()">Cancel</button>';
                    html += '</div>';
                    
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = html;
                    }
                    
                    window.waitingForOrderConfirmation = true;
                    userInput.placeholder = "Specify amounts like: '80lb Archives Blend and 60lb Ethiopia'";
                }
            } catch (error) {
                console.error('Error modifying order:', error);
                
                // Keep user in order mode even on error
                let html = '<div style="margin-bottom:12px;">Sorry, there was an error processing that. Please try again or use the Edit Order button.</div>';
                html += '<div class="response-buttons" style="margin-top: 12px;">';
                html += '<button class="action-btn" onclick="openEditOrderModal()">Edit Order</button>';
                html += '<button class="action-btn" onclick="showDefaultOrderInChat()">Show Current Order</button>';
                html += '<button class="action-btn" onclick="cancelRoastOrder()">Cancel</button>';
                html += '</div>';
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = html;
                }
                
                window.waitingForOrderConfirmation = true;
            }
        }

        // Open edit order modal
        function openEditOrderModal() {
            window.waitingForOrderConfirmation = false;
            
            // Build the edit form with current order items
            let html = '';
            
            // Get available roasted coffees for the dropdown
            const availableCoffees = roastedCoffeeInventory.map(c => c.name);
            
            pendingRoastOrder.forEach((item, index) => {
                // Calculate green coffee requirements for this item
                const roasted = roastedCoffeeInventory.find(r => r.name === item.name);
                let inventoryWarning = '';
                
                if (roasted && roasted.recipe) {
                    const greenNeeded = Math.round(item.weight / 0.85);
                    const warnings = [];
                    
                    roasted.recipe.forEach(comp => {
                        const greenCoffee = greenCoffeeInventory.find(g => g.id === comp.greenCoffeeId);
                        if (greenCoffee) {
                            const compNeeded = Math.round(greenNeeded * comp.percentage / 100);
                            if (compNeeded > greenCoffee.weight) {
                                warnings.push(`${greenCoffee.name}: need ${compNeeded}lb, only ${greenCoffee.weight}lb available`);
                            }
                        }
                    });
                    
                    if (warnings.length > 0) {
                        inventoryWarning = `<div style="color: #ff6b6b; font-size: 11px; margin-top: 6px;">‚ö†Ô∏è ${warnings.join(', ')}</div>`;
                    }
                }
                
                html += `<div style="background:#1a1a1a; padding:12px; border-radius:8px; margin-bottom:8px;" id="orderItem${index}">`;
                html += `<div style="display:flex; gap:10px; align-items:center;">`;
                html += `<select style="flex:1; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" data-order-coffee="${index}" onchange="validateOrderInventory()">`;
                availableCoffees.forEach(name => {
                    html += `<option value="${name}" ${item.name === name ? 'selected' : ''}>${name}</option>`;
                });
                html += `</select>`;
                html += `<label style="font-size:12px; color:white; display:flex; align-items:center; gap:4px;">`;
                html += `<input type="number" value="${item.weight}" style="width:70px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" data-order-weight="${index}" oninput="validateOrderInventory()"> lb</label>`;
                html += `<button onclick="removeOrderItem(${index})" style="background:#6a4141; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer;">√ó</button>`;
                html += `</div>`;
                html += `<div id="inventoryWarning${index}">${inventoryWarning}</div>`;
                html += `</div>`;
            });
            
            html += `<button onclick="addOrderItem()" style="background:#28a745; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer; margin-top:8px;">+ Add Coffee</button>`;
            
            document.getElementById('editOrderList').innerHTML = html;
            document.getElementById('editOrderModal').style.display = 'flex';
        }

        // Validate order inventory on input change
        function validateOrderInventory() {
            pendingRoastOrder.forEach((item, index) => {
                const coffeeEl = document.querySelector(`[data-order-coffee="${index}"]`);
                const weightEl = document.querySelector(`[data-order-weight="${index}"]`);
                const warningEl = document.getElementById(`inventoryWarning${index}`);
                
                if (!coffeeEl || !weightEl || !warningEl) return;
                
                const coffeeName = coffeeEl.value;
                const weight = parseFloat(weightEl.value) || 0;
                const roasted = roastedCoffeeInventory.find(r => r.name === coffeeName);
                
                let inventoryWarning = '';
                
                if (roasted && roasted.recipe && weight > 0) {
                    const greenNeeded = Math.round(weight / 0.85);
                    const warnings = [];
                    
                    roasted.recipe.forEach(comp => {
                        const greenCoffee = greenCoffeeInventory.find(g => g.id === comp.greenCoffeeId);
                        if (greenCoffee) {
                            const compNeeded = Math.round(greenNeeded * comp.percentage / 100);
                            if (compNeeded > greenCoffee.weight) {
                                warnings.push(`${greenCoffee.name}: need ${compNeeded}lb, only ${greenCoffee.weight}lb available`);
                            }
                        }
                    });
                    
                    if (warnings.length > 0) {
                        inventoryWarning = `<div style="color: #ff6b6b; font-size: 11px; margin-top: 6px;">‚ö†Ô∏è ${warnings.join(', ')}</div>`;
                    }
                }
                
                warningEl.innerHTML = inventoryWarning;
            });
        }

        // Close edit order modal
        function closeEditOrderModal() {
            document.getElementById('editOrderModal').style.display = 'none';
            window.waitingForOrderConfirmation = true;
        }

        // Add new item to order
        function addOrderItem() {
            const defaultCoffee = roastedCoffeeInventory[0];
            if (defaultCoffee) {
                pendingRoastOrder.push({
                    name: defaultCoffee.name,
                    type: defaultCoffee.type || 'Single Origin',
                    recipe: defaultCoffee.recipe,
                    weight: 55
                });
                openEditOrderModal(); // Re-render
            }
        }

        // Remove item from order
        function removeOrderItem(index) {
            pendingRoastOrder.splice(index, 1);
            openEditOrderModal(); // Re-render
        }

        // Apply edits from modal and regenerate summary
        async function applyOrderEdits() {
            // Collect updates from the form
            const updatedOrder = [];
            
            pendingRoastOrder.forEach((item, index) => {
                const coffeeEl = document.querySelector(`[data-order-coffee="${index}"]`);
                const weightEl = document.querySelector(`[data-order-weight="${index}"]`);
                
                if (coffeeEl && weightEl) {
                    const coffeeName = coffeeEl.value;
                    const weight = parseFloat(weightEl.value) || 0;
                    
                    if (weight > 0) {
                        const roasted = roastedCoffeeInventory.find(c => c.name === coffeeName);
                        const nameLower = coffeeName.toLowerCase();
                        
                        // Get recipe from inventory or use fallback
                        let recipe = roasted?.recipe;
                        let type = roasted?.type;
                        
                        // Fallback recipes
                        if (!recipe) {
                            if (nameLower.includes('archives') || nameLower.includes('blend')) {
                                recipe = [
                                    { greenCoffeeId: 'brazil-mogiano', name: 'Brazil Mogiano', percentage: 66.6667 },
                                    { greenCoffeeId: 'ethiopia-yirgacheffe', name: 'Ethiopia Yirgacheffe', percentage: 33.3333 }
                                ];
                                type = 'Blend';
                            } else if (nameLower.includes('ethiopia') && nameLower.includes('gera')) {
                                recipe = [{ greenCoffeeId: 'ethiopia-gera', name: 'Ethiopia Gera', percentage: 100 }];
                                type = 'Single Origin';
                            } else if (nameLower.includes('colombia') && !nameLower.includes('decaf')) {
                                recipe = [{ greenCoffeeId: 'colombia-antioquia', name: 'Colombia Antioquia', percentage: 100 }];
                                type = 'Single Origin';
                            } else if (nameLower.includes('decaf')) {
                                type = 'Private Label';
                            }
                        }
                        
                        updatedOrder.push({
                            name: coffeeName,
                            type: type || 'Single Origin',
                            recipe: recipe,
                            weight: weight
                        });
                    }
                }
            });
            
            if (updatedOrder.length === 0) {
                alert('Please add at least one coffee to the order.');
                return;
            }
            
            pendingRoastOrder = updatedOrder;
            closeEditOrderModal();
            
            // Disable all action buttons in previous messages to prevent stale actions
            const allMessages = chatContainer.querySelectorAll('.message');
            allMessages.forEach(msg => {
                const buttons = msg.querySelectorAll('.action-btn');
                buttons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                    btn.onclick = null;
                });
            });
            
            // Add placeholder message that showDefaultOrderInChat will update
            addMessage('Generating updated order...', false);
            showDefaultOrderInChat();
        }

        // Open customize blend modal
        function openCustomizeBlendModal() {
            window.waitingForOrderConfirmation = false;
            
            // Store the blend being customized
            window.customizingBlendIndex = pendingRoastOrder.findIndex(item => 
                item.type === 'Blend' || (item.name && item.name.toLowerCase().includes('blend'))
            );
            
            if (window.customizingBlendIndex === -1) {
                // No blend in order - use first item or create new blend
                window.customizingBlendIndex = 0;
            }
            
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem) {
                alert('No items in order to customize.');
                return;
            }
            
            // Initialize custom recipe if not exists
            if (!blendItem.customRecipe) {
                blendItem.customRecipe = blendItem.recipe ? 
                    blendItem.recipe.map(r => ({ ...r })) : 
                    [{ greenCoffeeId: 'brazil-mogiano', name: 'Brazil Mogiano', percentage: 100 }];
            }
            
            renderCustomizeBlendModal();
            document.getElementById('customizeBlendModal').style.display = 'flex';
        }

        // Render customize blend modal content
        function renderCustomizeBlendModal() {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem) return;
            
            let html = `<div style="margin-bottom: 15px;">`;
            html += `<strong>${blendItem.name}</strong> (~${blendItem.weight}lb roasted)`;
            html += `</div>`;
            
            html += `<div style="margin-bottom: 10px; color: #aaa; font-size: 12px;">Green coffee components:</div>`;
            
            // Available green coffees
            const availableGreens = greenCoffeeInventory.map(g => ({
                id: g.id,
                name: g.name,
                weight: g.weight
            }));
            
            blendItem.customRecipe.forEach((comp, index) => {
                const greenCoffee = greenCoffeeInventory.find(g => g.id === comp.greenCoffeeId);
                const available = greenCoffee ? greenCoffee.weight : 0;
                const totalGreenNeeded = Math.round(blendItem.weight / 0.85);
                const compGreenNeeded = Math.round(totalGreenNeeded * comp.percentage / 100);
                const exceedsInventory = compGreenNeeded > available;
                
                html += `<div style="background:#1a1a1a; padding:12px; border-radius:8px; margin-bottom:8px; ${exceedsInventory ? 'border: 1px solid #ff6b6b;' : ''}">`;
                html += `<div style="display:flex; gap:10px; align-items:center; flex-wrap: wrap;">`;
                
                // Green coffee dropdown
                html += `<select style="flex:1; min-width: 150px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" data-blend-green="${index}" onchange="updateBlendComponent(${index}, 'green', this.value)">`;
                availableGreens.forEach(g => {
                    html += `<option value="${g.id}" ${comp.greenCoffeeId === g.id ? 'selected' : ''}>${g.name} (${g.weight}lb avail)</option>`;
                });
                html += `</select>`;
                
                // Percentage input
                html += `<label style="font-size:12px; color:white; display:flex; align-items:center; gap:4px;">`;
                html += `<input type="number" value="${comp.percentage}" min="1" max="100" style="width:60px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" data-blend-pct="${index}" onchange="updateBlendComponent(${index}, 'percentage', this.value)"> %</label>`;
                
                // Remove button (only if more than 1 component)
                if (blendItem.customRecipe.length > 1) {
                    html += `<button onclick="removeBlendComponent(${index})" style="background:#6a4141; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer;">√ó</button>`;
                }
                
                html += `</div>`;
                
                // Show weight needed and inventory warning
                html += `<div style="font-size: 11px; margin-top: 6px; color: ${exceedsInventory ? '#ff6b6b' : '#888'};">`;
                html += `Needs ~${compGreenNeeded}lb green`;
                if (exceedsInventory) {
                    html += ` ‚ö†Ô∏è Exceeds inventory (only ${available}lb available)`;
                }
                html += `</div>`;
                
                html += `</div>`;
            });
            
            // Add component button
            html += `<button onclick="addBlendComponent()" style="background:#28a745; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer; margin-top:8px;">+ Add Green Coffee</button>`;
            
            // Total percentage check
            const totalPct = blendItem.customRecipe.reduce((sum, c) => sum + (parseFloat(c.percentage) || 0), 0);
            if (Math.abs(totalPct - 100) > 0.1) {
                html += `<div style="color: #f0ad4e; margin-top: 12px; font-size: 12px;">‚ö†Ô∏è Percentages total ${totalPct.toFixed(1)}% (should be 100%)</div>`;
            }
            
            document.getElementById('customizeBlendList').innerHTML = html;
            updateInventoryWarnings();
        }

        // Update blend component
        function updateBlendComponent(index, field, value) {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem || !blendItem.customRecipe[index]) return;
            
            if (field === 'green') {
                const greenCoffee = greenCoffeeInventory.find(g => g.id === value);
                blendItem.customRecipe[index].greenCoffeeId = value;
                blendItem.customRecipe[index].name = greenCoffee ? greenCoffee.name : value;
            } else if (field === 'percentage') {
                blendItem.customRecipe[index].percentage = parseFloat(value) || 0;
            }
            
            renderCustomizeBlendModal();
        }

        // Add new blend component
        function addBlendComponent() {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem) return;
            
            // Find a green coffee not already in the blend
            const usedIds = blendItem.customRecipe.map(c => c.greenCoffeeId);
            const availableGreen = greenCoffeeInventory.find(g => !usedIds.includes(g.id));
            
            if (availableGreen) {
                blendItem.customRecipe.push({
                    greenCoffeeId: availableGreen.id,
                    name: availableGreen.name,
                    percentage: 10
                });
            } else {
                // All greens used, add the first one
                const firstGreen = greenCoffeeInventory[0];
                blendItem.customRecipe.push({
                    greenCoffeeId: firstGreen?.id || 'unknown',
                    name: firstGreen?.name || 'Unknown',
                    percentage: 10
                });
            }
            
            renderCustomizeBlendModal();
        }

        // Remove blend component
        function removeBlendComponent(index) {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem || blendItem.customRecipe.length <= 1) return;
            
            blendItem.customRecipe.splice(index, 1);
            renderCustomizeBlendModal();
        }

        // Update inventory warnings display
        function updateInventoryWarnings() {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem) return;
            
            const warnings = [];
            const totalGreenNeeded = Math.round(blendItem.weight / 0.85);
            
            blendItem.customRecipe.forEach(comp => {
                const greenCoffee = greenCoffeeInventory.find(g => g.id === comp.greenCoffeeId);
                const available = greenCoffee ? greenCoffee.weight : 0;
                const compGreenNeeded = Math.round(totalGreenNeeded * comp.percentage / 100);
                
                if (compGreenNeeded > available) {
                    warnings.push(`${comp.name}: need ${compGreenNeeded}lb, only ${available}lb available`);
                }
            });
            
            const warningsDiv = document.getElementById('inventoryWarnings');
            if (warnings.length > 0) {
                warningsDiv.innerHTML = `<div style="background: #4a3030; padding: 10px; border-radius: 8px; color: #ff6b6b; font-size: 12px;">
                    <strong>‚ö†Ô∏è Inventory Warning:</strong><br>
                    ${warnings.join('<br>')}
                </div>`;
            } else {
                warningsDiv.innerHTML = '';
            }
        }

        // Close customize blend modal
        function closeCustomizeBlendModal() {
            document.getElementById('customizeBlendModal').style.display = 'none';
            window.waitingForOrderConfirmation = true;
        }

        // Apply blend customization
        function applyBlendCustomization() {
            const blendItem = pendingRoastOrder[window.customizingBlendIndex];
            if (!blendItem) return;
            
            // Validate percentages sum to 100
            const totalPct = blendItem.customRecipe.reduce((sum, c) => sum + (parseFloat(c.percentage) || 0), 0);
            if (Math.abs(totalPct - 100) > 0.5) {
                alert(`Percentages must total 100%. Currently: ${totalPct.toFixed(1)}%`);
                return;
            }
            
            // Apply custom recipe to the blend
            blendItem.recipe = blendItem.customRecipe.map(c => ({
                greenCoffeeId: c.greenCoffeeId,
                name: c.name,
                percentage: c.percentage
            }));
            
            // Clear custom recipe storage
            delete blendItem.customRecipe;
            
            closeCustomizeBlendModal();
            
            // Disable old buttons
            const allMessages = chatContainer.querySelectorAll('.message');
            allMessages.forEach(msg => {
                const buttons = msg.querySelectorAll('.action-btn');
                buttons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                    btn.onclick = null;
                });
            });
            
            // Re-render order summary
            addMessage('Generating updated order...', false);
            showDefaultOrderInChat();
        }

        // Finalize roast order (shared by chat and modal confirm)
        async function finalizeRoastOrder(emailData) {
            addMessage('Confirming order...', false);
            
            try {
                const response = await fetch('/api/roast-order/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderItems: pendingRoastOrder,
                        emailData: emailData
                    })
                });
                
                const data = await response.json();
                
                // Handle Google not connected
                if (response.status === 401) {
                    handleGoogleDisconnected();
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = `<div style="color: #dc3545;">‚ö†Ô∏è ${data.error || 'Google account not connected.'}</div>
                            <div style="margin-top: 8px;">Please connect your Google account to create email drafts.</div>
                            <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('roast_order')">Connect Google Account</button>`;
                    }
                    return;
                }
                
                // Handle order errors (insufficient inventory, etc.)
                if (!data.success) {
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = `<div style="color: #dc3545;">‚ö†Ô∏è ${data.message || 'Error confirming order.'}</div>`;
                    }
                    return;
                }
                
                // Show confirmation message
                let confirmHtml = '<strong>Roast Order Confirmed</strong><br><br>';
                
                if (data.deductions && data.deductions.length > 0) {
                    confirmHtml += 'Green coffee inventory updated:<br>';
                    data.deductions.forEach(d => {
                        confirmHtml += `   ${d.name}: -${d.deducted}lb (${d.remaining}lb remaining)<br>`;
                    });
                    confirmHtml += '<br>';
                }
                
                confirmHtml += `Added ${data.enRouteItems?.length || 0} item(s) to en route.`;
                
                if (data.draftCreated) {
                    confirmHtml += '<br>Email draft created in Gmail.';
                }
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = confirmHtml;
                }
                
                // Reload inventory
                await loadInventory();
                
                // Reset state
                pendingRoastOrder = [];
                pendingRoastEmail = null;
                waitingForRoastOrder = false;
                window.waitingForOrderConfirmation = false;
                userInput.placeholder = 'Describe what you want to do‚Ä¶';
                
                // Add conversational follow-up
                addConversationalFollowUp('roast_order_confirmed');
                
            } catch (error) {
                console.error('Error confirming order:', error);
                addMessage('Error confirming order: ' + error.message, false);
            }
        }

        // Open Roast Order Configuration Modal (kept for edit functionality)
        function openRoastOrderModal() {
            const configDiv = document.getElementById('roastOrderConfig');
            let html = '';
            
            pendingRoastOrder.forEach((item, index) => {
                html += `<div style="background:#1a1a1a; padding:15px; border-radius:8px; margin-bottom:10px;">`;
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">`;
                html += `<strong style="color:#90EE90;">${item.name}</strong>`;
                html += `<span style="background:${item.type === 'Blend' ? '#4a6741' : item.type === 'Single Origin' ? '#41576a' : '#6a5741'}; padding:2px 8px; border-radius:4px; font-size:12px;">${item.type}</span>`;
                html += `<button onclick="removeFromOrder(${index})" style="background:#6a4141; border:none; color:white; padding:4px 10px; border-radius:4px; cursor:pointer;">Remove</button>`;
                html += `</div>`;
                
                if (item.type === 'Single Origin') {
                    html += `<div style="display:flex; gap:15px; align-items:center;">`;
                    html += `<label>Batches: <input type="number" id="batches-${index}" value="${item.batches}" min="1" max="10" style="width:60px; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" onchange="updateOrderItem(${index}, 'batches', this.value)"></label>`;
                    html += `<label>√ó <input type="number" id="batchWeight-${index}" value="${item.batchWeight}" min="20" max="50" style="width:60px; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" onchange="updateOrderItem(${index}, 'batchWeight', this.value)"> lb each</label>`;
                    html += `<span style="color:#888;">= <strong id="total-${index}">${item.batches * item.batchWeight}</strong> lb</span>`;
                    html += `</div>`;
                } else if (item.type === 'Blend') {
                    html += `<div style="margin-bottom:8px; color:#888; font-size:13px;">Recipe: ${item.recipe ? item.recipe.map(r => `${r.percentage}% ${r.name}`).join(' + ') : 'N/A'}</div>`;
                    html += `<div style="display:flex; gap:15px; align-items:center;">`;
                    html += `<label>Total Weight: <input type="number" id="weight-${index}" value="${item.weight}" min="10" max="500" step="5" style="width:80px; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" onchange="updateOrderItem(${index}, 'weight', this.value)"> lb</label>`;
                    html += `</div>`;
                    if (item.recipe) {
                        html += `<div style="margin-top:8px; color:#888; font-size:12px;">Components: `;
                        item.recipe.forEach(r => {
                            const compWeight = Math.round(item.weight * r.percentage / 100);
                            html += `${r.name}: ~${compWeight}lb `;
                        });
                        html += `</div>`;
                    }
                } else {
                    // Private Label
                    html += `<div style="display:flex; gap:15px; align-items:center;">`;
                    html += `<label>Weight: <input type="number" id="weight-${index}" value="${item.weight}" min="5" max="200" step="5" style="width:80px; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" onchange="updateOrderItem(${index}, 'weight', this.value)"> lb</label>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
            });
            
            if (pendingRoastOrder.length === 0) {
                html = '<div style="color:#888; text-align:center; padding:20px;">No items in order. Please add coffees first.</div>';
            }
            
            configDiv.innerHTML = html;
            document.getElementById('roastOrderModal').style.display = 'flex';
        }

        function updateOrderItem(index, field, value) {
            if (field === 'batches') {
                pendingRoastOrder[index].batches = parseInt(value) || 1;
                pendingRoastOrder[index].weight = pendingRoastOrder[index].batches * pendingRoastOrder[index].batchWeight;
                const totalEl = document.getElementById(`total-${index}`);
                if (totalEl) totalEl.textContent = pendingRoastOrder[index].weight;
            } else if (field === 'batchWeight') {
                pendingRoastOrder[index].batchWeight = parseInt(value) || 30;
                pendingRoastOrder[index].weight = pendingRoastOrder[index].batches * pendingRoastOrder[index].batchWeight;
                const totalEl = document.getElementById(`total-${index}`);
                if (totalEl) totalEl.textContent = pendingRoastOrder[index].weight;
            } else if (field === 'weight') {
                pendingRoastOrder[index].weight = parseInt(value) || 20;
            }
        }

        function removeFromOrder(index) {
            pendingRoastOrder.splice(index, 1);
            openRoastOrderModal(); // Refresh
        }

        function closeRoastOrderModal() {
            document.getElementById('roastOrderModal').style.display = 'none';
            pendingRoastOrder = [];
            waitingForRoastOrder = false;
            userInput.placeholder = 'Describe what you want to do‚Ä¶';
        }

        // Generate Roast Order Email (from modal)
        async function generateRoastOrderEmail() {
            if (pendingRoastOrder.length === 0) {
                alert('No items in order');
                return;
            }
            
            try {
                const response = await fetch('/api/roast-order/generate-email', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orderItems: pendingRoastOrder })
                });
                
                const data = await response.json();
                pendingRoastEmail = data;
                
                // Close config modal, open email preview
                document.getElementById('roastOrderModal').style.display = 'none';
                document.getElementById('roastEmailTo').value = data.to;
                document.getElementById('roastEmailSubject').value = data.subject;
                document.getElementById('roastEmailBody').value = data.body;
                document.getElementById('roastEmailModal').style.display = 'flex';
                
            } catch (error) {
                console.error('Error generating email:', error);
                alert('Error generating email: ' + error.message);
            }
        }

        function closeRoastEmailModal() {
            document.getElementById('roastEmailModal').style.display = 'none';
        }

        // Confirm Roast Order (from modal)
        async function confirmRoastOrder() {
            const emailData = {
                to: document.getElementById('roastEmailTo').value,
                subject: document.getElementById('roastEmailSubject').value,
                body: document.getElementById('roastEmailBody').value
            };
            
            document.getElementById('roastEmailModal').style.display = 'none';
            await finalizeRoastOrder(emailData);
        }

        // Confirm roast order with copy to clipboard (from modal)
        async function confirmRoastOrderWithCopy() {
            const to = document.getElementById('roastEmailTo').value;
            const subject = document.getElementById('roastEmailSubject').value;
            const body = document.getElementById('roastEmailBody').value;
            
            document.getElementById('roastEmailModal').style.display = 'none';
            
            addMessage('Validating inventory and updating...', false);
            
            try {
                // First, update inventory and en route
                const response = await fetch('/api/roast-order/confirm-no-draft', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderItems: pendingRoastOrder
                    })
                });
                
                const data = await response.json();
                
                // Check for inventory shortage
                if (data.success === false) {
                    let errorHtml = '<strong style="color: #ff6b6b;">Order Cannot Be Confirmed</strong><br><br>';
                    errorHtml += `<div style="color: #ff6b6b; margin-bottom: 12px;">${data.message}</div>`;
                    
                    if (data.shortages && data.shortages.length > 0) {
                        errorHtml += '<div style="margin-bottom: 12px;">Shortages:</div>';
                        data.shortages.forEach(s => {
                            errorHtml += `<div style="color: #ff6b6b;">‚Ä¢ ${s.name}: need ${s.required}lb, only ${s.available}lb available</div>`;
                        });
                    }
                    
                    errorHtml += '<br><div>Please reduce the order quantities or add more green coffee inventory.</div>';
                    
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = errorHtml;
                    }
                    
                    // Re-open the modal so user can adjust
                    document.getElementById('roastEmailModal').style.display = 'flex';
                    return;
                }
                
                // Only copy email if inventory update succeeded
                const emailText = `To: ${to}\nSubject: ${subject}\n\n${body}`;
                await navigator.clipboard.writeText(emailText);
                
                // Show confirmation message
                let confirmHtml = '<strong>Order Confirmed & Email Copied</strong><br><br>';
                confirmHtml += '<div style="color: #90EE90; margin-bottom: 12px;">‚úì Email copied - paste into your email client</div>';
                
                if (data.deductions && data.deductions.length > 0) {
                    confirmHtml += 'Green coffee inventory updated:<br>';
                    data.deductions.forEach(d => {
                        confirmHtml += `   ${d.name}: -${d.deducted}lb (${d.remaining}lb remaining)<br>`;
                    });
                    confirmHtml += '<br>';
                }
                
                confirmHtml += `Added ${data.enRouteItems?.length || 0} item(s) to en route.`;
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = confirmHtml;
                }
                
                // Reload inventory
                await loadInventory();
                
                // Reset state
                pendingRoastOrder = [];
                pendingRoastEmail = null;
                waitingForRoastOrder = false;
                window.waitingForOrderConfirmation = false;
                userInput.placeholder = 'Describe what you want to do‚Ä¶';
                
                // Add conversational follow-up
                addConversationalFollowUp('roast_order_confirmed');
                
            } catch (error) {
                console.error('Error confirming order:', error);
                addMessage('Error: ' + error.message, false);
            }
        }

        // ============ Manage Wholesale Customers ============
        
        let wholesaleCustomers = [];
        let existingCodes = [];
        let tier1Prices = {};
        
        async function openManageCustomers() {
            document.getElementById('manageCustomersModal').style.display = 'flex';
            await loadCustomersList();
        }
        
        function closeManageCustomersModal() {
            document.getElementById('manageCustomersModal').style.display = 'none';
        }
        
        async function loadCustomersList() {
            const listDiv = document.getElementById('customersList');
            listDiv.innerHTML = '<div style="color: #888;">Loading customers...</div>';
            
            try {
                const response = await fetch('/api/customers/wholesale');
                const data = await response.json();
                
                if (!data.success) {
                    listDiv.innerHTML = '<div style="color: #ff6b6b;">Error loading customers</div>';
                    return;
                }
                
                wholesaleCustomers = data.customers || [];
                existingCodes = data.existingCodes || [];
                tier1Prices = data.tier1Prices || {};
                
                if (wholesaleCustomers.length === 0) {
                    listDiv.innerHTML = '<div style="color: #888;">No wholesale customers found</div>';
                    return;
                }
                
                let html = '<div style="display: grid; grid-template-columns: 2fr 1fr 1.5fr 1.5fr 1.5fr; gap: 8px; padding: 8px 12px; background: #2a2a2a; border-radius: 4px; margin-bottom: 8px; font-size: 11px; color: #888;">';
                html += '<div>Customer</div>';
                html += '<div>Code</div>';
                html += '<div>Pricing Table</div>';
                html += '<div>Customer Since</div>';
                html += '<div>Last Invoice</div>';
                html += '</div>';
                
                wholesaleCustomers.forEach(customer => {
                    html += `<div style="display: grid; grid-template-columns: 2fr 1fr 1.5fr 1.5fr 1.5fr; gap: 8px; padding: 12px; background: #1a1a1a; border-radius: 8px; margin-bottom: 8px; align-items: center;">`;
                    html += `<div style="font-weight: 500;">${customer.name}</div>`;
                    html += `<div style="color: #90EE90; font-family: monospace;">${customer.code}</div>`;
                    html += `<div style="color: #888; font-size: 12px;">${customer.pricingTable || 'Tier 1'}</div>`;
                    html += `<div style="color: #888; font-size: 12px;">${customer.dateSince || 'N/A'}</div>`;
                    html += `<div style="color: #888; font-size: 12px;">${customer.lastInvoice || 'No invoices'}</div>`;
                    html += `</div>`;
                });
                
                listDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading customers:', error);
                listDiv.innerHTML = '<div style="color: #ff6b6b;">Error loading customers: ' + error.message + '</div>';
            }
        }
        
        function openAddCustomerModal() {
            // Clear fields
            document.getElementById('newCustomerName').value = '';
            document.getElementById('newCustomerCode').value = '';
            document.getElementById('newCustomerEmails').value = '';
            document.getElementById('newCustomerPricingType').value = 'existing';
            document.getElementById('newCustomerPricingTable').value = 'tier1';
            document.getElementById('newCustomerPriceRatio').value = '1.00';
            document.getElementById('codeValidation').textContent = '';
            document.getElementById('codeValidation').style.color = '#888';
            
            updatePricingTypeUI();
            document.getElementById('addCustomerModal').style.display = 'flex';
        }
        
        function closeAddCustomerModal() {
            document.getElementById('addCustomerModal').style.display = 'none';
        }
        
        function validateCustomerCode() {
            const codeInput = document.getElementById('newCustomerCode');
            const validation = document.getElementById('codeValidation');
            const code = codeInput.value.toUpperCase();
            
            codeInput.value = code;
            
            if (code.length < 3) {
                validation.textContent = 'Enter 3 letters';
                validation.style.color = '#888';
                return false;
            }
            
            if (!/^[A-Z]{3}$/.test(code)) {
                validation.textContent = 'Letters only';
                validation.style.color = '#ff6b6b';
                return false;
            }
            
            if (existingCodes.includes(code)) {
                validation.textContent = '‚ùå Code already in use';
                validation.style.color = '#ff6b6b';
                return false;
            }
            
            validation.textContent = '‚úì Available';
            validation.style.color = '#90EE90';
            return true;
        }
        
        function updatePricingTypeUI() {
            const pricingType = document.getElementById('newCustomerPricingType').value;
            document.getElementById('existingPricingSection').style.display = pricingType === 'existing' ? 'block' : 'none';
            document.getElementById('customPricingSection').style.display = pricingType === 'custom' ? 'block' : 'none';
            
            if (pricingType === 'custom') {
                updateCustomPricingPreview();
            }
        }
        
        function updateCustomPricingPreview() {
            const ratio = parseFloat(document.getElementById('newCustomerPriceRatio').value) || 1.0;
            const preview = document.getElementById('customPricingPreview');
            
            if (Object.keys(tier1Prices).length === 0) {
                preview.innerHTML = '<span style="color: #888;">No pricing data available</span>';
                return;
            }
            
            let html = '<div style="color: #90EE90; margin-bottom: 8px;">Price Examples (ratio: ' + ratio.toFixed(2) + '):</div>';
            
            let count = 0;
            for (const [coffee, price] of Object.entries(tier1Prices)) {
                if (count >= 3) break;
                const customPrice = (price * ratio).toFixed(2);
                html += `<div style="margin-bottom: 4px;">${coffee}: $${price.toFixed(2)} ‚Üí <span style="color: #90EE90;">$${customPrice}</span></div>`;
                count++;
            }
            
            preview.innerHTML = html;
        }
        
        async function confirmAddCustomer() {
            const name = document.getElementById('newCustomerName').value.trim();
            const code = document.getElementById('newCustomerCode').value.toUpperCase().trim();
            const emailsRaw = document.getElementById('newCustomerEmails').value.trim();
            const pricingType = document.getElementById('newCustomerPricingType').value;
            
            if (!name) {
                alert('Please enter a customer name.');
                return;
            }
            
            if (!validateCustomerCode()) {
                alert('Please enter a valid unique 3-letter code.');
                return;
            }
            
            const emails = emailsRaw ? emailsRaw.split(',').map(e => e.trim()).filter(e => e) : [];
            
            let pricingTable = null;
            let priceRatio = null;
            
            if (pricingType === 'existing') {
                pricingTable = document.getElementById('newCustomerPricingTable').value;
            } else {
                priceRatio = parseFloat(document.getElementById('newCustomerPriceRatio').value) || 1.0;
            }
            
            closeAddCustomerModal();
            
            try {
                const response = await fetch('/api/customers/wholesale/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        code,
                        emails,
                        pricingType,
                        pricingTable,
                        priceRatio
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    alert('Error adding customer: ' + (result.error || 'Unknown error'));
                    return;
                }
                
                // Reload the customers list
                await loadCustomersList();
                
                let successMsg = `Added ${name} (${code}) as a wholesale customer.`;
                if (result.pricingCreated) {
                    successMsg += `\n\nCustom pricing table "Wholesale ${name}" created with ratio ${priceRatio}√ó Tier 1.`;
                }
                
                alert(successMsg);
                
            } catch (error) {
                console.error('Error adding customer:', error);
                alert('Error adding customer: ' + error.message);
            }
        }

        // ============ Manage Inventory Modal ============

        function openManageInventory() {
            loadInventory().then(() => {
                renderInventoryModal();
                document.getElementById('inventoryModal').style.display = 'flex';
            });
        }

        function renderInventoryModal() {
            // Green coffee list - simplified to one line
            let greenHtml = '';
            greenCoffeeInventory.forEach((coffee, index) => {
                greenHtml += `<div style="background:#1a1a1a; padding:10px 12px; border-radius:8px; margin-bottom:8px;">`;
                greenHtml += `<div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">`;
                greenHtml += `<input type="text" value="${coffee.name}" placeholder="Name" style="flex:2; min-width:140px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-green-name="${index}">`;
                greenHtml += `<input type="number" value="${coffee.weight}" placeholder="0" style="width:60px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-green-weight="${index}">`;
                greenHtml += `<span style="color:#888; font-size:12px;">lb</span>`;
                greenHtml += `<input type="text" value="${coffee.roastProfile || ''}" placeholder="Profile" style="width:70px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-green-profile="${index}">`;
                greenHtml += `<input type="text" value="${coffee.dropTemp || ''}" placeholder="Drop¬∞F" style="width:60px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-green-droptemp="${index}">`;
                greenHtml += `<button onclick="removeGreenCoffee(${index})" style="background:#6a4141; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer;" title="Remove">√ó</button>`;
                greenHtml += `</div>`;
                greenHtml += `</div>`;
            });
            document.getElementById('greenCoffeeList').innerHTML = greenHtml || '<div style="color:#888;">No green coffee in inventory</div>';
            
            // Roasted coffee list - simplified: name, weight, type, recipe (blends only)
            let roastedHtml = '';
            const typeOptions = ['Single Origin', 'Blend', 'Private Label'];
            
            roastedCoffeeInventory.forEach((coffee, index) => {
                roastedHtml += `<div style="background:#1a1a1a; padding:10px 12px; border-radius:8px; margin-bottom:8px;">`;
                
                // Main row: Name, Weight, Type, Remove button
                roastedHtml += `<div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">`;
                roastedHtml += `<input type="text" value="${coffee.name}" placeholder="Name" style="flex:2; min-width:140px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-roasted-name="${index}">`;
                roastedHtml += `<input type="number" value="${coffee.weight}" placeholder="0" style="width:60px; padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-roasted-weight="${index}">`;
                roastedHtml += `<span style="color:#888; font-size:12px;">lb</span>`;
                roastedHtml += `<select style="padding:6px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" data-roasted-type="${index}" onchange="updateRoastedTypeUI(${index})">`;
                typeOptions.forEach(type => {
                    roastedHtml += `<option value="${type}" ${coffee.type === type ? 'selected' : ''}>${type}</option>`;
                });
                roastedHtml += `</select>`;
                roastedHtml += `<button onclick="removeRoastedCoffee(${index})" style="background:#6a4141; border:none; color:white; padding:6px 10px; border-radius:4px; cursor:pointer;" title="Remove">√ó</button>`;
                roastedHtml += `</div>`;
                
                // Recipe section - only for Blends
                if (coffee.type === 'Blend') {
                    roastedHtml += `<div style="background:#2a2a2a; padding:8px; border-radius:4px; margin-top:8px;">`;
                    roastedHtml += `<div style="font-size:11px; color:#888; margin-bottom:6px;">Recipe:</div>`;
                    
                    if (coffee.recipe && coffee.recipe.length > 0) {
                        coffee.recipe.forEach((comp, compIndex) => {
                            roastedHtml += `<div style="display:flex; gap:8px; align-items:center; margin-bottom:4px;">`;
                            roastedHtml += `<select style="flex:1; padding:4px; background:#1a1a1a; border:1px solid #444; color:white; border-radius:4px; font-size:12px;" data-roasted-recipe-green="${index}-${compIndex}">`;
                            greenCoffeeInventory.forEach(green => {
                                roastedHtml += `<option value="${green.id}" ${comp.greenCoffeeId === green.id ? 'selected' : ''}>${green.name}</option>`;
                            });
                            roastedHtml += `</select>`;
                            roastedHtml += `<input type="number" value="${comp.percentage}" placeholder="%" style="width:55px; padding:4px; background:#1a1a1a; border:1px solid #444; color:white; border-radius:4px; font-size:12px;" data-roasted-recipe-pct="${index}-${compIndex}">`;
                            roastedHtml += `<span style="font-size:11px; color:#888;">%</span>`;
                            roastedHtml += `<button onclick="removeRecipeComponent(${index}, ${compIndex})" style="background:#4a3030; border:none; color:#999; padding:2px 6px; border-radius:4px; cursor:pointer; font-size:10px;">√ó</button>`;
                            roastedHtml += `</div>`;
                        });
                    } else {
                        roastedHtml += `<div style="color:#666; font-size:11px; font-style:italic;">No recipe defined</div>`;
                    }
                    
                    roastedHtml += `<button onclick="addRecipeComponent(${index})" style="background:#28a745; border:none; color:white; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px; margin-top:6px;">+ Add Component</button>`;
                    roastedHtml += `</div>`;
                }
                
                roastedHtml += `</div>`;
            });
            document.getElementById('roastedCoffeeList').innerHTML = roastedHtml || '<div style="color:#888;">No roasted coffee in inventory</div>';
        }

        // Update UI when roasted coffee type changes
        function updateRoastedTypeUI(index) {
            const typeEl = document.querySelector(`[data-roasted-type="${index}"]`);
            if (typeEl) {
                roastedCoffeeInventory[index].type = typeEl.value;
                if (typeEl.value === 'Blend' && !roastedCoffeeInventory[index].recipe) {
                    // Initialize empty recipe for blends
                    roastedCoffeeInventory[index].recipe = [];
                }
                renderInventoryModal();
            }
        }

        // Add recipe component to roasted coffee
        function addRecipeComponent(roastedIndex) {
            const coffee = roastedCoffeeInventory[roastedIndex];
            if (!coffee.recipe) coffee.recipe = [];
            
            // Find first green coffee not already in recipe
            const usedIds = coffee.recipe.map(c => c.greenCoffeeId);
            const availableGreen = greenCoffeeInventory.find(g => !usedIds.includes(g.id)) || greenCoffeeInventory[0];
            
            if (availableGreen) {
                coffee.recipe.push({
                    greenCoffeeId: availableGreen.id,
                    name: availableGreen.name,
                    percentage: coffee.recipe.length === 0 ? 100 : 0
                });
                renderInventoryModal();
            }
        }

        // Remove recipe component from roasted coffee
        function removeRecipeComponent(roastedIndex, compIndex) {
            const coffee = roastedCoffeeInventory[roastedIndex];
            if (coffee.recipe && coffee.recipe.length > compIndex) {
                coffee.recipe.splice(compIndex, 1);
                renderInventoryModal();
            }
        }

        function openAddGreenCoffeeModal() {
            // Clear previous values
            document.getElementById('newGreenName').value = '';
            document.getElementById('newGreenWeight').value = '';
            document.getElementById('newGreenTotalCost').value = '';
            document.getElementById('newGreenProfile').value = '';
            document.getElementById('newGreenDropTemp').value = '';
            document.getElementById('newGreenCostPerLb').style.display = 'none';
            
            // Add event listeners for cost calculation
            const weightInput = document.getElementById('newGreenWeight');
            const costInput = document.getElementById('newGreenTotalCost');
            
            const updateCostPerLb = () => {
                const weight = parseFloat(weightInput.value) || 0;
                const totalCost = parseFloat(costInput.value) || 0;
                const costPerLbDiv = document.getElementById('newGreenCostPerLb');
                const costPerLbValue = document.getElementById('costPerLbValue');
                
                if (weight > 0 && totalCost > 0) {
                    const costPerLb = totalCost / weight;
                    costPerLbValue.textContent = '$' + costPerLb.toFixed(2);
                    costPerLbDiv.style.display = 'block';
                } else {
                    costPerLbDiv.style.display = 'none';
                }
            };
            
            weightInput.oninput = updateCostPerLb;
            costInput.oninput = updateCostPerLb;
            
            document.getElementById('addGreenCoffeeModal').style.display = 'flex';
        }
        
        function closeAddGreenCoffeeModal() {
            document.getElementById('addGreenCoffeeModal').style.display = 'none';
        }
        
        async function confirmAddGreenCoffee() {
            const name = document.getElementById('newGreenName').value.trim();
            const weight = parseFloat(document.getElementById('newGreenWeight').value) || 0;
            const totalCost = parseFloat(document.getElementById('newGreenTotalCost').value) || 0;
            const roastProfile = document.getElementById('newGreenProfile').value.trim();
            const dropTemp = document.getElementById('newGreenDropTemp').value.trim();
            
            if (!name) {
                alert('Please enter a coffee name.');
                return;
            }
            
            if (weight <= 0) {
                alert('Please enter a valid weight.');
                return;
            }
            
            if (totalCost <= 0) {
                alert('Please enter a valid total cost.');
                return;
            }
            
            closeAddGreenCoffeeModal();
            
            try {
                // Add to pricing sheet first
                const pricingResponse = await fetch('/api/pricing/add-coffee', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        weight: weight,
                        totalCost: totalCost
                    })
                });
                
                const pricingResult = await pricingResponse.json();
                
                if (!pricingResult.success) {
                    alert('Error adding to pricing sheet: ' + (pricingResult.error || 'Unknown error'));
                    return;
                }
                
                // Add to local inventory
                greenCoffeeInventory.push({
                    id: name.toLowerCase().replace(/\s+/g, '-'),
                    name: name,
                    weight: weight,
                    roastProfile: roastProfile,
                    dropTemp: dropTemp
                });
                
                renderInventoryModal();
                
                // Show success message
                const costPerLb = (totalCost / weight).toFixed(2);
                alert(`Added ${name} to inventory and pricing sheet.\n\nCost per lb: $${costPerLb}\nAt-Cost price: $${pricingResult.atCostPrice?.toFixed(2) || 'calculated'}/lb`);
                
            } catch (error) {
                console.error('Error adding green coffee:', error);
                alert('Error adding coffee: ' + error.message);
            }
        }
        
        // Legacy function for simple add (now opens modal)
        function addGreenCoffee() {
            openAddGreenCoffeeModal();
        }

        function removeGreenCoffee(index) {
            if (confirm(`Remove "${greenCoffeeInventory[index]?.name || 'this coffee'}" from inventory?`)) {
                greenCoffeeInventory.splice(index, 1);
                renderInventoryModal();
            }
        }

        function openAddRoastedCoffeeModal() {
            // Clear previous values
            document.getElementById('newRoastedName').value = '';
            document.getElementById('newRoastedWeight').value = '';
            document.getElementById('newRoastedType').value = 'Single Origin';
            document.getElementById('newRoastedWholesalePrice').value = '';
            document.getElementById('newRoastedPricePreview').style.display = 'none';
            document.getElementById('newRoastedRecipeInfo').style.display = 'block';
            
            // Store At-Cost prices for margin calculation
            window.atCostPrices = {};
            
            // Fetch At-Cost prices
            fetch('/api/pricing/at-cost-prices')
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        window.atCostPrices = data.prices;
                    }
                })
                .catch(err => console.log('Could not fetch At-Cost prices:', err));
            
            updateRoastedTypePreview();
            document.getElementById('addRoastedCoffeeModal').style.display = 'flex';
        }
        
        function closeAddRoastedCoffeeModal() {
            document.getElementById('addRoastedCoffeeModal').style.display = 'none';
        }
        
        function updateRoastedTypePreview() {
            const type = document.getElementById('newRoastedType').value;
            const name = document.getElementById('newRoastedName').value.trim();
            const recipeInfo = document.getElementById('newRoastedRecipeInfo');
            const recipeText = document.getElementById('newRoastedRecipeText');
            
            if (type === 'Single Origin') {
                recipeInfo.style.display = 'block';
                recipeText.textContent = name ? `100% ${name} (matching green coffee)` : 'Will use matching green coffee';
            } else if (type === 'Blend') {
                recipeInfo.style.display = 'block';
                recipeText.textContent = 'Configure recipe in inventory modal after adding';
                recipeText.style.color = '#f0ad4e';
            } else {
                recipeInfo.style.display = 'block';
                recipeText.textContent = 'Private Label - no recipe required';
                recipeText.style.color = '#888';
            }
            
            updateRoastedPreview();
        }
        
        function updateRoastedPreview() {
            const name = document.getElementById('newRoastedName').value.trim();
            const wholesalePrice = parseFloat(document.getElementById('newRoastedWholesalePrice').value) || 0;
            const previewDiv = document.getElementById('newRoastedPricePreview');
            
            if (wholesalePrice > 0) {
                previewDiv.style.display = 'block';
                document.getElementById('roastedTier1Price').textContent = '$' + wholesalePrice.toFixed(2) + '/lb';
                
                // Try to find At-Cost price for margin calculation
                let atCostPrice = null;
                if (window.atCostPrices && name) {
                    // Look for matching At-Cost price (try exact match first, then partial)
                    const nameLower = name.toLowerCase();
                    for (const [coffeeName, price] of Object.entries(window.atCostPrices)) {
                        if (coffeeName.toLowerCase() === nameLower || 
                            coffeeName.toLowerCase().includes(nameLower) ||
                            nameLower.includes(coffeeName.toLowerCase())) {
                            atCostPrice = price;
                            break;
                        }
                    }
                }
                
                if (atCostPrice !== null) {
                    document.getElementById('roastedAtCostPrice').textContent = '$' + atCostPrice.toFixed(2) + '/lb';
                    const margin = wholesalePrice - atCostPrice;
                    const marginColor = margin >= 0 ? '#90EE90' : '#ff6b6b';
                    document.getElementById('roastedMargin').textContent = '$' + margin.toFixed(2) + '/lb';
                    document.getElementById('roastedMargin').style.color = marginColor;
                } else {
                    document.getElementById('roastedAtCostPrice').textContent = 'Not found (add green coffee first)';
                    document.getElementById('roastedAtCostPrice').style.color = '#f0ad4e';
                    document.getElementById('roastedMargin').textContent = 'N/A';
                    document.getElementById('roastedMargin').style.color = '#888';
                }
            } else {
                previewDiv.style.display = 'none';
            }
        }
        
        async function confirmAddRoastedCoffee() {
            const name = document.getElementById('newRoastedName').value.trim();
            const weight = parseFloat(document.getElementById('newRoastedWeight').value) || 0;
            const type = document.getElementById('newRoastedType').value;
            const wholesalePrice = parseFloat(document.getElementById('newRoastedWholesalePrice').value) || 0;
            
            if (!name) {
                alert('Please enter a coffee name.');
                return;
            }
            
            if (wholesalePrice <= 0) {
                alert('Please enter a valid Wholesale Tier 1 price.');
                return;
            }
            
            closeAddRoastedCoffeeModal();
            
            try {
                // Add to all wholesale pricing tables
                const pricingResponse = await fetch('/api/pricing/add-roasted-coffee', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        wholesaleTier1Price: wholesalePrice
                    })
                });
                
                const pricingResult = await pricingResponse.json();
                
                if (!pricingResult.success) {
                    alert('Error adding to pricing sheet: ' + (pricingResult.error || 'Unknown error'));
                    return;
                }
                
                // Build recipe for single origin
                let recipe = [];
                if (type === 'Single Origin') {
                    // Find matching green coffee
                    const matchingGreen = greenCoffeeInventory.find(g => 
                        g.name.toLowerCase() === name.toLowerCase() ||
                        g.name.toLowerCase().includes(name.toLowerCase()) ||
                        name.toLowerCase().includes(g.name.toLowerCase())
                    );
                    
                    if (matchingGreen) {
                        recipe = [{ greenCoffeeId: matchingGreen.id, name: matchingGreen.name, percentage: 100 }];
                    }
                }
                
                // Add to local inventory
                roastedCoffeeInventory.push({
                    id: name.toLowerCase().replace(/\s+/g, '-') + '-roasted',
                    name: name,
                    weight: weight,
                    type: type,
                    recipe: type === 'Private Label' ? null : recipe
                });
                
                renderInventoryModal();
                
                // Show success message with calculated prices
                let successMsg = `Added ${name} to inventory and all pricing tables.\n\n`;
                successMsg += `Wholesale Tier 1: $${wholesalePrice.toFixed(2)}/lb\n`;
                if (pricingResult.calculatedPrices) {
                    successMsg += `Wholesale Dex: $${pricingResult.calculatedPrices.dex.toFixed(2)}/lb\n`;
                    successMsg += `Wholesale CED: $${pricingResult.calculatedPrices.ced.toFixed(2)}/lb\n`;
                    successMsg += `Wholesale Junia: $${pricingResult.calculatedPrices.junia.toFixed(2)}/lb`;
                }
                
                alert(successMsg);
                
            } catch (error) {
                console.error('Error adding roasted coffee:', error);
                alert('Error adding coffee: ' + error.message);
            }
        }
        
        // Legacy function for simple add (now opens modal)
        function addRoastedCoffee() {
            openAddRoastedCoffeeModal();
        }

        function removeRoastedCoffee(index) {
            if (confirm(`Remove "${roastedCoffeeInventory[index]?.name || 'this coffee'}" from inventory?`)) {
                roastedCoffeeInventory.splice(index, 1);
                renderInventoryModal();
            }
        }

        async function saveInventoryChanges() {
            // Confirm before saving
            if (!confirm('Save all inventory changes?')) {
                return;
            }
            
            // Collect green coffee updates (simplified fields only)
            greenCoffeeInventory.forEach((coffee, index) => {
                const nameEl = document.querySelector(`[data-green-name="${index}"]`);
                const weightEl = document.querySelector(`[data-green-weight="${index}"]`);
                const profileEl = document.querySelector(`[data-green-profile="${index}"]`);
                const dropTempEl = document.querySelector(`[data-green-droptemp="${index}"]`);
                
                if (nameEl) coffee.name = nameEl.value;
                if (weightEl) coffee.weight = parseFloat(weightEl.value) || 0;
                if (profileEl) coffee.roastProfile = profileEl.value || '';
                if (dropTempEl) coffee.dropTemp = parseInt(dropTempEl.value) || 0;
                coffee.id = coffee.name.toLowerCase().replace(/\s+/g, '-');
            });
            
            // Collect roasted coffee updates (simplified: name, weight, type, recipe for blends)
            roastedCoffeeInventory.forEach((coffee, index) => {
                const nameEl = document.querySelector(`[data-roasted-name="${index}"]`);
                const weightEl = document.querySelector(`[data-roasted-weight="${index}"]`);
                const typeEl = document.querySelector(`[data-roasted-type="${index}"]`);
                
                if (nameEl) coffee.name = nameEl.value;
                if (weightEl) coffee.weight = parseFloat(weightEl.value) || 0;
                if (typeEl) coffee.type = typeEl.value;
                coffee.id = coffee.name.toLowerCase().replace(/\s+/g, '-') + '-roasted';
                
                // Collect recipe components only for Blends
                if (coffee.type === 'Blend' && coffee.recipe) {
                    coffee.recipe.forEach((comp, compIndex) => {
                        const greenEl = document.querySelector(`[data-roasted-recipe-green="${index}-${compIndex}"]`);
                        const pctEl = document.querySelector(`[data-roasted-recipe-pct="${index}-${compIndex}"]`);
                        
                        if (greenEl) {
                            comp.greenCoffeeId = greenEl.value;
                            const greenCoffee = greenCoffeeInventory.find(g => g.id === greenEl.value);
                            comp.name = greenCoffee ? greenCoffee.name : greenEl.value;
                        }
                        if (pctEl) comp.percentage = parseFloat(pctEl.value) || 0;
                    });
                }
            });
            
            // Save to server
            try {
                for (const coffee of greenCoffeeInventory) {
                    await fetch('/api/inventory/green/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(coffee)
                    });
                }
                
                for (const coffee of roastedCoffeeInventory) {
                    await fetch('/api/inventory/roasted/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(coffee)
                    });
                }
                
                closeInventoryModal();
                addMessage('Inventory updated successfully.', false);
                addConversationalFollowUp('inventory_updated');
            } catch (error) {
                console.error('Error saving inventory:', error);
                alert('Error saving inventory: ' + error.message);
            }
        }

        function closeInventoryModal() {
            document.getElementById('inventoryModal').style.display = 'none';
        }

        // ============ To Do Feature ============
        
        async function showToDo() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();
            
            addMessage('Checking pending tasks...', false);
            
            try {
                const response = await fetch('/api/todo');
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to get to do items');
                }
                
                // Get the last message and update it
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                const content = lastMsg?.querySelector('.message-content') || lastMsg;
                
                if (data.todoItems.length === 0) {
                    content.innerHTML = `<div style="color: #4a6741;">All caught up! No pending tasks.</div>`;
                    addConversationalFollowUp('todo_empty');
                    return;
                }
                
                let html = `<div style="margin-bottom: 16px;"><strong>To Do List</strong> <span style="color:#888;">(${data.count} item${data.count > 1 ? 's' : ''})</span></div>`;
                
                data.todoItems.forEach((item, index) => {
                    html += `<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 10px;">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: flex-start;">`;
                    html += `<div style="flex: 1;">`;
                    html += `<div style="font-weight: 600; margin-bottom: 4px;">${item.title}</div>`;
                    
                    // Handle multi-line descriptions (inventory overview)
                    if (item.type === 'inventory_overview') {
                        const lines = item.description.split('\n');
                        html += `<div style="font-size: 13px;">`;
                        
                        // Group items by type
                        const greenItems = [];
                        const roastedItems = [];
                        const enRouteItems = [];
                        
                        lines.forEach(line => {
                            if (line.includes('lb green)')) {
                                greenItems.push(line);
                            } else if (line.includes('lb roasted)')) {
                                roastedItems.push(line);
                            } else if (line.includes('en route)') || line.includes('Needs tracking') || line.includes('Check delivery')) {
                                enRouteItems.push(line);
                            }
                        });
                        
                        // Helper to clean up display text (remove type label since we have section headers)
                        const cleanText = (text) => {
                            return text
                                .replace(/\s*\(\d+lb green\)/, '')
                                .replace(/\s*\(\d+lb roasted\)/, '')
                                .replace(/\s*\(\d+lb en route\)/, '');
                        };
                        
                        // Extract weight for cleaner display
                        const formatItem = (text) => {
                            const weightMatch = text.match(/\((\d+)lb/);
                            const weight = weightMatch ? weightMatch[1] : '0';
                            const nameMatch = text.match(/^(.+?)\s*\(/);
                            const name = nameMatch ? nameMatch[1] : text.split(' - ')[0];
                            const status = text.includes('Very Low') ? 'Very Low, order soon' : text.includes('Low') ? 'Low' : 
                                          text.includes('Needs tracking') ? 'Needs tracking' : 
                                          text.includes('Check delivery') ? 'Check delivery' : '';
                            return `${name} ‚Äî ${weight}lb ${status ? '‚Äî ' + status : ''}`;
                        };
                        
                        // Display green coffee section
                        if (greenItems.length > 0) {
                            html += `<div style="color: #ccc; font-weight: 600; margin: 8px 0 4px 0; font-size: 11px; text-transform: uppercase;">Green Coffee</div>`;
                            greenItems.forEach(line => {
                                const [status, ...textParts] = line.split('|');
                                const text = textParts.join('|');
                                const textColor = status === 'critical' ? '#ff6b6b' : '#999';
                                html += `<div style="margin: 2px 0 2px 8px; color: ${textColor};">${formatItem(text)}</div>`;
                            });
                        }
                        
                        // Display roasted coffee section
                        if (roastedItems.length > 0) {
                            html += `<div style="color: #ccc; font-weight: 600; margin: 10px 0 4px 0; font-size: 11px; text-transform: uppercase;">Roasted Coffee</div>`;
                            roastedItems.forEach(line => {
                                const [status, ...textParts] = line.split('|');
                                const text = textParts.join('|');
                                const textColor = status === 'critical' ? '#ff6b6b' : '#999';
                                html += `<div style="margin: 2px 0 2px 8px; color: ${textColor};">${formatItem(text)}</div>`;
                            });
                        }
                        
                        // Display en route section
                        if (enRouteItems.length > 0) {
                            html += `<div style="color: #ccc; font-weight: 600; margin: 10px 0 4px 0; font-size: 11px; text-transform: uppercase;">En Route</div>`;
                            enRouteItems.forEach(line => {
                                const [status, ...textParts] = line.split('|');
                                const text = textParts.join('|');
                                html += `<div style="margin: 2px 0 2px 8px; color: #999;">${formatItem(text)}</div>`;
                            });
                        }
                        
                        html += `</div>`;
                    } else if (item.type === 'outstanding_invoices') {
                        // Display outstanding invoices grouped by customer
                        const lines = item.description.split('\n');
                        html += `<div style="font-size: 13px;">`;
                        
                        lines.forEach(line => {
                            const [type, ...textParts] = line.split('|');
                            const text = textParts.join('|');
                            
                            if (type === 'customer') {
                                html += `<div style="color: #ccc; font-weight: 600; margin: 8px 0 4px 0; font-size: 12px;">${text}</div>`;
                            } else if (type === 'invoice') {
                                html += `<div style="margin: 2px 0 2px 12px; color: #999;">${text}</div>`;
                            }
                        });
                        
                        html += `</div>`;
                    } else if (item.type === 'retail_overview') {
                        // Display retail weeks with sections
                        const lines = item.description.split('\n');
                        html += `<div style="font-size: 13px;">`;
                        
                        lines.forEach(line => {
                            const [type, ...textParts] = line.split('|');
                            const text = textParts.join('|');
                            
                            if (type === 'header') {
                                html += `<div style="color: #ccc; font-weight: 600; margin: 8px 0 4px 0; font-size: 11px; text-transform: uppercase;">${text}</div>`;
                            } else if (type === 'missing') {
                                html += `<div style="margin: 2px 0 2px 8px; color: #999;">${text}</div>`;
                            } else if (type === 'completed') {
                                html += `<div style="margin: 2px 0 2px 8px; color: #999;">${text}</div>`;
                            }
                        });
                        
                        html += `</div>`;
                    } else {
                        html += `<div style="color: #999; font-size: 13px;">${item.description}</div>`;
                    }
                    
                    html += `</div>`;
                    
                    // Different buttons for inventory_overview
                    if (item.type === 'inventory_overview') {
                        html += `<div style="display: flex; flex-direction: column; gap: 6px; margin-left: 10px;">`;
                        html += `<button class="action-btn" onclick="startRoastOrder()" style="font-size: 11px; padding: 5px 10px;">Order Roast</button>`;
                        html += `<button class="action-btn" onclick="openManageInventory()" style="font-size: 11px; padding: 5px 10px;">Manage</button>`;
                        html += `</div>`;
                    } else {
                        html += `<button class="action-btn" onclick="${getToDoAction(item)}" style="margin-left: 10px; font-size: 11px; padding: 5px 10px;">`;
                        html += `${getToDoButtonText(item.type)}`;
                        html += `</button>`;
                    }
                    html += `</div>`;
                    html += `</div>`;
                });
                
                // Add Done button
                html += `<div style="margin-top: 16px;">`;
                html += `<button class="action-btn" onclick="addFollowUpMessage()">Done</button>`;
                html += `</div>`;
                
                content.innerHTML = html;
                
            } catch (error) {
                console.error('To Do error:', error);
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = `<div style="color: #ff6b6b;">Error loading to do list: ${error.message}</div>`;
                }
            }
        }
        
        function getToDoAction(item) {
            switch (item.type) {
                case 'inventory_overview':
                    return 'checkCurrentInventory()';
                case 'outstanding_invoices':
                    return 'showOutstandingInvoices()';
                case 'retail_overview':
                    return 'manageRetail()';
                default:
                    return '';
            }
        }
        
        function getToDoButtonText(type) {
            switch (type) {
                case 'inventory_overview':
                    return 'View ‚Üí';
                case 'outstanding_invoices':
                    return 'Send Reminders';
                case 'retail_overview':
                    return 'Manage Retail';
                default:
                    return 'Go ‚Üí';
            }
        }
        
        async function showOutstandingInvoices() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();
            
            addMessage('Loading outstanding invoices...', false);
            
            try {
                const response = await fetch('/api/invoices/outstanding');
                const data = await response.json();
                
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                const content = lastMsg?.querySelector('.message-content') || lastMsg;
                
                if (!data.groupedInvoices || data.groupedInvoices.length === 0) {
                    content.innerHTML = `<div style="color: #4a6741;">‚úÖ No outstanding invoices!</div>`;
                    addConversationalFollowUp('invoices_clear');
                    return;
                }
                
                let html = `<div style="margin-bottom: 12px;"><strong>Outstanding Invoices</strong></div>`;
                
                // Display grouped by customer
                data.groupedInvoices.forEach((group, groupIndex) => {
                    const hasEmail = group.customerEmails && group.customerEmails.length > 0;
                    const totalFormatted = `$${group.totalAmount.toFixed(2)}`;
                    
                    html += `<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 10px;">`;
                    
                    // Customer header
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #444;">`;
                    html += `<div>`;
                    html += `<div style="font-weight: 600; font-size: 15px;">${group.customerName}</div>`;
                    html += `<div style="color: #f0ad4e; font-size: 13px;">${group.invoices.length} invoice${group.invoices.length > 1 ? 's' : ''} ‚Ä¢ Total: ${totalFormatted}</div>`;
                    html += `</div>`;
                    html += `<div>`;
                    if (hasEmail) {
                        html += `<button class="action-btn" onclick="draftInvoiceReminder(${groupIndex})" style="font-size: 11px; padding: 6px 12px; background: #4a6741;">Draft Reminder</button>`;
                    } else {
                        html += `<button class="action-btn" style="font-size: 11px; padding: 6px 12px; background: #555; cursor: not-allowed;" disabled title="No email on file">No Email</button>`;
                    }
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Invoice list for this customer
                    group.invoices.forEach(inv => {
                        html += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #333;">`;
                        html += `<div style="font-size: 13px;">`;
                        html += `<span style="color: #90EE90;">${inv.invoiceNumber}</span>`;
                        html += `<span style="color: #888; margin-left: 10px;">${inv.date}</span>`;
                        html += `</div>`;
                        html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                        html += `<span style="font-size: 13px;">${inv.amount}</span>`;
                        html += `<button class="action-btn" onclick="markInvoicePaidPrompt('${inv.invoiceNumber}')" style="font-size: 10px; padding: 4px 8px;">Paid</button>`;
                        html += `</div>`;
                        html += `</div>`;
                    });
                    
                    html += `</div>`;
                });
                
                // Store grouped data for draft reminder function
                window.outstandingInvoicesData = data.groupedInvoices;
                
                // Add navigation buttons
                html += `<div style="display: flex; gap: 8px; margin-top: 16px;">`;
                html += `<button class="action-btn" onclick="showToDo()">‚Üê Back to To Do</button>`;
                html += `<button class="action-btn" onclick="addFollowUpMessage()">Done</button>`;
                html += `</div>`;
                
                content.innerHTML = html;
                
            } catch (error) {
                console.error('Outstanding invoices error:', error);
                addMessage('Error loading invoices: ' + error.message, false);
            }
        }
        
        async function draftInvoiceReminder(groupIndex) {
            const group = window.outstandingInvoicesData[groupIndex];
            if (!group) {
                addMessage('Error: Could not find customer data.', false);
                return;
            }
            
            if (!group.customerEmails || group.customerEmails.length === 0) {
                addMessage(`‚ùå No email on file for ${group.customerName}. Please add an email first.`, false);
                return;
            }
            
            // Store the group data for when the modal is confirmed
            window.pendingReminderGroup = group;
            
            const invoiceCount = group.invoices.length;
            const totalFormatted = `$${group.totalAmount.toFixed(2)}`;
            const invoiceList = group.invoices.map(inv => {
                const amt = inv.amountNum || parseFloat(String(inv.amount).replace(/[$,]/g, '')) || 0;
                return `${inv.invoiceNumber} - ${inv.date} - $${amt.toFixed(2)}`;
            }).join('\n');
            
            // Populate modal
            document.getElementById('reminderEmailTo').value = group.customerEmails[0];
            document.getElementById('reminderEmailSubject').value = `Payment Reminder - ${invoiceCount} Outstanding Invoice${invoiceCount > 1 ? 's' : ''} (${totalFormatted})`;
            document.getElementById('reminderEmailBody').value = 
`Hi ${group.customerName},

This is a friendly reminder that you have ${invoiceCount} outstanding invoice${invoiceCount > 1 ? 's' : ''} totaling ${totalFormatted}:

${invoiceList}

The invoice${invoiceCount > 1 ? 's are' : ' is'} attached to this email for your reference. If you've already sent payment, please disregard this message.

Please let us know if you have any questions.

Thank you,
Archives of Us Coffee`;
            
            // Show modal
            document.getElementById('invoiceReminderModal').style.display = 'flex';
        }
        
        function closeInvoiceReminderModal() {
            document.getElementById('invoiceReminderModal').style.display = 'none';
            window.pendingReminderGroup = null;
        }
        
        async function confirmInvoiceReminder() {
            const group = window.pendingReminderGroup;
            if (!group) {
                closeInvoiceReminderModal();
                return;
            }
            
            // Get edited values from modal
            const editedTo = document.getElementById('reminderEmailTo').value;
            const editedSubject = document.getElementById('reminderEmailSubject').value;
            const editedBody = document.getElementById('reminderEmailBody').value;
            
            closeInvoiceReminderModal();
            
            try {
                addMessage(`Creating draft reminder for ${group.customerName}...`, false);
                
                const response = await fetch('/api/invoices/draft-reminder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customerName: group.customerName,
                        customerEmails: [editedTo],
                        invoices: group.invoices,
                        totalAmount: group.totalAmount,
                        customSubject: editedSubject,
                        customBody: editedBody
                    })
                });
                
                const result = await response.json();
                
                // Update the last message with the result
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    if (result.success) {
                        content.innerHTML = `‚úÖ ${result.message}`;
                    } else {
                        content.innerHTML = `‚ùå ${result.error || 'Failed to create draft'}`;
                    }
                }
                
                addConversationalFollowUp('draft_reminder_created');
                
            } catch (error) {
                console.error('Draft reminder error:', error);
                addMessage(`‚ùå Error creating draft: ${error.message}`, false);
            }
        }
        
        async function sendInvoiceReminder(invoiceNumber, customerName, customerEmails, amount, invoiceDate) {
            if (!customerEmails || customerEmails.length === 0) {
                addMessage(`‚ùå No email on file for ${customerName || 'this customer'}. Please add an email first.`, false);
                return;
            }
            
            const confirmSend = confirm(`Send payment reminder for ${invoiceNumber} (${amount}) to ${customerEmails[0]}?`);
            if (!confirmSend) return;
            
            try {
                addMessage(`üìß Sending reminder to ${customerEmails[0]}...`, false);
                
                const response = await fetch('/api/invoices/send-reminder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        invoiceNumber,
                        customerName,
                        customerEmails,
                        amount,
                        invoiceDate
                    })
                });
                
                const data = await response.json();
                
                // Update the last message
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                const content = lastMsg?.querySelector('.message-content') || lastMsg;
                
                if (data.success) {
                    content.innerHTML = `<div style="color: #4a6741;">‚úÖ Reminder sent to ${data.to}</div>`;
                } else {
                    content.innerHTML = `<div style="color: #ff6b6b;">‚ùå ${data.error}</div>`;
                }
                
                addConversationalFollowUp('reminder_sent');
                
            } catch (error) {
                console.error('Send reminder error:', error);
                addMessage('Error sending reminder: ' + error.message, false);
            }
        }
        
        async function markInvoicePaidPrompt(invoiceNumber) {
            const today = new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
            const paidDate = prompt(`Mark ${invoiceNumber} as paid on:`, today);
            
            if (!paidDate) return;
            
            try {
                const response = await fetch('/api/invoices/mark-paid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ invoiceNumber, paidDate })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage(`‚úÖ ${invoiceNumber} marked as paid on ${paidDate}`, false);
                    addConversationalFollowUp('invoice_paid');
                } else {
                    addMessage(`Error: ${data.error}`, false);
                }
            } catch (error) {
                addMessage('Error marking invoice paid: ' + error.message, false);
            }
        }

        // ============ Forecast Feature ============
        
        async function showForecast() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();
            
            addMessage('Generating forecast and analytics...', false);
            
            try {
                const response = await fetch('/api/forecast');
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to generate forecast');
                }
                
                const forecast = data.forecast;
                
                // Get the last message and update it
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                const content = lastMsg?.querySelector('.message-content') || lastMsg;
                
                let html = '<div style="margin-bottom: 16px;"><strong>üìä Business Forecast</strong></div>';
                
                // Sales Summary
                html += '<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 12px;">';
                html += '<div style="font-weight: 600; margin-bottom: 8px; color: #4a9eff;">üí∞ Sales Analytics</div>';
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">';
                html += `<div>Wholesale Avg/Week: <strong>$${forecast.salesAnalytics.wholesale.avgWeeklySales.toFixed(0)}</strong></div>`;
                html += `<div>Retail Avg/Week: <strong>$${forecast.salesAnalytics.retail.avgWeeklySales.toFixed(0)}</strong></div>`;
                html += `<div>Est. Lbs Sold/Week: <strong>${forecast.salesAnalytics.wholesale.estimatedLbsPerWeek} lb</strong></div>`;
                html += `<div>Wholesale Avg/Month: <strong>$${forecast.salesAnalytics.wholesale.avgMonthlySales.toFixed(0)}</strong></div>`;
                html += '</div>';
                html += '</div>';
                
                // Inventory Predictions - Roasted
                html += '<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 12px;">';
                html += '<div style="font-weight: 600; margin-bottom: 8px; color: #f0ad4e;">‚òï Roasted Coffee Forecast</div>';
                html += '<div style="font-size: 13px;">';
                Object.entries(forecast.inventoryPredictions.roasted).forEach(([name, pred]) => {
                    const statusIcon = pred.status === 'critical' ? 'üî¥' : pred.status === 'low' ? 'üü°' : 'üü¢';
                    html += `<div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">`;
                    html += `<span>${statusIcon} ${name}</span>`;
                    html += `<span>${pred.currentStock}lb ‚Ä¢ ~${pred.estimatedWeeklyUsage}lb/wk ‚Ä¢ ${pred.weeksRemaining}wk left</span>`;
                    html += `</div>`;
                });
                html += '</div>';
                html += '</div>';
                
                // Inventory Predictions - Green
                html += '<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 12px;">';
                html += '<div style="font-weight: 600; margin-bottom: 8px; color: #4a6741;">üå± Green Coffee Forecast</div>';
                html += '<div style="font-size: 13px;">';
                Object.entries(forecast.inventoryPredictions.green).forEach(([name, pred]) => {
                    const statusIcon = pred.status === 'critical' ? 'üî¥' : pred.status === 'low' ? 'üü°' : 'üü¢';
                    html += `<div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">`;
                    html += `<span>${statusIcon} ${name}</span>`;
                    html += `<span>${pred.currentStock}lb ‚Ä¢ ~${pred.estimatedWeeklyUsage}lb/wk ‚Ä¢ ${pred.weeksRemaining}wk left</span>`;
                    html += `</div>`;
                });
                html += '</div>';
                html += '</div>';
                
                // Recommendations
                if (forecast.recommendations.length > 0) {
                    html += '<div style="background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 12px;">';
                    html += '<div style="font-weight: 600; margin-bottom: 8px; color: #ff6b6b;">‚ö° Recommendations</div>';
                    html += '<div style="font-size: 13px;">';
                    forecast.recommendations.forEach(rec => {
                        const icon = rec.priority === 'high' ? 'üî¥' : rec.priority === 'medium' ? 'üü°' : 'üü¢';
                        html += `<div style="padding: 4px 0;">${icon} ${rec.message}</div>`;
                        if (rec.suggestedQuantity) {
                            html += `<div style="padding-left: 20px; color: #888;">‚Üí Suggested: ${rec.suggestedQuantity} lb</div>`;
                        }
                    });
                    html += '</div>';
                    html += '</div>';
                } else {
                    html += '<div style="background: #2a3a2a; border-radius: 8px; padding: 12px; margin-bottom: 12px; color: #4a6741;">';
                    html += '‚úÖ All inventory levels healthy - no immediate orders needed';
                    html += '</div>';
                }
                
                // Link to sheet
                html += '<div style="margin-top: 12px; font-size: 12px; color: #888;">';
                html += 'üìÑ Full forecast written to Google Sheet "Forecast" tab';
                html += '</div>';
                
                content.innerHTML = html;
                
                // Add follow-up buttons
                setTimeout(() => {
                    addForecastFollowUp();
                }, 100);
                
            } catch (error) {
                console.error('Forecast error:', error);
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = `<div style="color: #ff6b6b;">Error generating forecast: ${error.message}</div>`;
                }
            }
        }
        
        function addForecastFollowUp() {
            let html = '<div style="margin-bottom: 12px;">What would you like to do next?</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
            html += '<button class="action-btn" onclick="startRoastOrder()">üî• Order Roast</button>';
            html += '<button class="action-btn" onclick="checkCurrentInventory()">‚òï Check Inventory</button>';
            html += '<button class="action-btn" onclick="addFollowUpMessage()">Something Else</button>';
            html += '</div>';
            
            addMessage(html, false);
        }

        // ============ En Route Modal ============

        async function viewEnRoute() {
            // Clear welcome message
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();
            
            await loadInventory();
            
            if (enRouteCoffeeInventory.length === 0) {
                addMessage('No coffee currently en route.', false);
                setTimeout(() => {
                    addConversationalFollowUp('en_route_empty');
                }, 300);
                return;
            }
            
            // Group items by dateOrdered (same date/time = same roast order)
            const orderGroups = {};
            enRouteCoffeeInventory.forEach(item => {
                const orderKey = item.dateOrdered || 'unknown';
                if (!orderGroups[orderKey]) {
                    orderGroups[orderKey] = [];
                }
                orderGroups[orderKey].push(item);
            });
            
            let html = '<strong>üöö En Route Coffee</strong><br><br>';
            
            Object.keys(orderGroups).forEach((orderDate, groupIndex) => {
                const items = orderGroups[orderDate];
                const firstItem = items[0];
                
                // Format order date - handle mm/dd/yy format
                let orderDateStr = orderDate;
                if (orderDate && orderDate !== 'unknown' && !orderDate.match(/^\d{2}\/\d{2}\/\d{2}$/)) {
                    const date = new Date(orderDate);
                    if (!isNaN(date.getTime())) {
                        const m = String(date.getMonth() + 1).padStart(2, '0');
                        const d = String(date.getDate()).padStart(2, '0');
                        const y = String(date.getFullYear()).slice(-2);
                        orderDateStr = `${m}/${d}/${y}`;
                    }
                }
                
                // Check if this group has tracking
                const hasTracking = firstItem.trackingNumber && firstItem.trackingNumber.trim() !== '';
                
                html += `<div style="background:#1a1a1a; padding:12px; border-radius:8px; margin-bottom:10px;">`;
                
                // Show all items in this order group
                items.forEach((item, idx) => {
                    html += `<div style="margin-bottom:${idx < items.length - 1 ? '4px' : '8px'};">`;
                    html += `<strong style="color:#90EE90;">${item.name}</strong> - ${item.weight}lb`;
                    html += `</div>`;
                });
                
                if (orderDateStr && orderDateStr !== 'unknown') {
                    html += `<div style="font-size:12px; color:#888; margin-bottom:8px;">Ordered: ${orderDateStr}</div>`;
                }
                
                // Show estimated delivery prominently if available
                if (firstItem.estimatedDelivery) {
                    html += `<div style="padding:8px; background:#2a3a2a; border-radius:4px; margin-bottom:8px;">`;
                    html += `<span style="color:#90EE90; font-weight:bold;">üì¶ Est. Delivery: ${firstItem.estimatedDelivery}</span>`;
                    html += `</div>`;
                }
                
                html += `<div style="display:flex; gap:8px; flex-wrap:wrap;">`;
                // Use first item's ID and tracking for the group
                html += `<button class="action-btn" onclick="viewTracking('${firstItem.id}', '${firstItem.trackingNumber || ''}')" style="font-size:12px; padding:6px 10px;">Tracking</button>`;
                html += `<button class="action-btn" onclick="startMarkDeliveredGroup('${orderDate}')" style="font-size:12px; padding:6px 10px; background:#4a6741;">Mark Delivered</button>`;
                html += `</div>`;
                html += `</div>`;
            });
            
            // Add Done button at the end
            html += `<div style="margin-top: 12px;">`;
            html += `<button class="action-btn" onclick="addFollowUpMessage()">Done</button>`;
            html += `</div>`;
            
            addMessage(html, false);
        }
        
        async function viewTracking(itemId, trackingNumber) {
            if (!trackingNumber || trackingNumber.trim() === '') {
                // No tracking - check how many orders need tracking
                const ordersWithoutTracking = getOrdersWithoutTracking();
                
                if (ordersWithoutTracking.length === 0) {
                    addMessage('All orders have tracking numbers.', false);
                    return;
                }
                
                if (ordersWithoutTracking.length === 1) {
                    // Single order - simple text prompt
                    const order = ordersWithoutTracking[0];
                    const itemsList = order.items.map(i => `${i.weight}lb ${i.name}`).join(', ');
                    addMessage(`No tracking number for: ${itemsList}`, false);
                    
                    let html = '<div style="margin-top:8px;">Enter tracking number:</div>';
                    html += `<div style="display:flex; gap:8px; margin-top:8px;">`;
                    html += `<input type="text" id="singleTrackingInput" placeholder="1Z..." style="flex:1; padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;">`;
                    html += `<button class="action-btn" onclick="saveSingleTracking('${order.dateKey}')" style="padding:8px 12px;">Save</button>`;
                    html += `</div>`;
                    
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML += html;
                    }
                } else {
                    // Multiple orders - show table modal
                    openTrackingModal();
                }
                return;
            }
            
            // Has tracking - show tracking info from stored data
            const item = enRouteCoffeeInventory.find(i => i.id === itemId);
            
            let html = `<strong>Tracking: ${trackingNumber}</strong><br><br>`;
            
            // Show estimated delivery if stored
            if (item && item.estimatedDelivery) {
                html += `<div style="padding:10px; background:#2a3a2a; border-radius:6px; margin-bottom:12px;">`;
                html += `<span style="color:#90EE90; font-size:16px; font-weight:bold;">üì¶ Est. Delivery: ${item.estimatedDelivery}</span>`;
                html += `</div>`;
            }
            
            html += `<a href="https://www.ups.com/track?tracknum=${trackingNumber}" target="_blank" style="color:#90EE90; font-weight:bold;">üì¶ View on UPS.com ‚Üí</a>`;
            
            // Show delivery date input if not set
            if (!item?.estimatedDelivery) {
                html += `<div style="margin-top:12px; padding:10px; background:#1a1a1a; border-radius:6px;">`;
                html += `<span style="color:#ccc; font-size:13px;">Enter delivery date from UPS:</span><br>`;
                html += `<div style="display:flex; gap:8px; margin-top:6px;">`;
                html += `<input type="text" id="chatDeliveryDate" placeholder="mm/dd/yy" style="padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; width:100px;">`;
                html += `<button class="action-btn" onclick="saveChatDeliveryDate('${itemId}')" style="padding:8px 12px;">Save</button>`;
                html += `</div></div>`;
            }
            
            addMessage(html, false);
        }
        
        // Save delivery date from chat view
        async function saveChatDeliveryDate(itemId) {
            const input = document.getElementById('chatDeliveryDate');
            const deliveryDate = input?.value?.trim();
            const item = enRouteCoffeeInventory.find(i => i.id === itemId);
            
            if (!deliveryDate) {
                alert('Please enter a delivery date');
                return;
            }
            
            try {
                await fetch('/api/inventory/enroute/tracking', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        id: itemId, 
                        trackingNumber: item?.trackingNumber || '',
                        manualDeliveryDate: deliveryDate 
                    })
                });
                
                await loadInventory();
                addMessage(`üì¶ Delivery date saved: ${deliveryDate}`, false);
                addConversationalFollowUp('tracking_updated');
                
            } catch (error) {
                console.error('Error saving delivery date:', error);
                addMessage('Error saving delivery date.', false);
            }
        }
        
        // Get orders grouped by date that don't have tracking
        function getOrdersWithoutTracking() {
            const orderGroups = {};
            enRouteCoffeeInventory.forEach(item => {
                if (!item.trackingNumber || item.trackingNumber.trim() === '') {
                    const orderKey = item.dateOrdered || 'unknown';
                    if (!orderGroups[orderKey]) {
                        orderGroups[orderKey] = [];
                    }
                    orderGroups[orderKey].push(item);
                }
            });
            
            return Object.keys(orderGroups).map(dateKey => ({
                dateKey,
                items: orderGroups[dateKey]
            }));
        }
        
        // Save tracking for single order
        async function saveSingleTracking(dateKey) {
            const input = document.getElementById('singleTrackingInput');
            const trackingNumber = input?.value?.trim();
            
            if (!trackingNumber) {
                alert('Please enter a tracking number');
                return;
            }
            
            // Update all items with this date
            const itemsToUpdate = enRouteCoffeeInventory.filter(item => 
                (item.dateOrdered || 'unknown') === dateKey
            );
            
            try {
                for (const item of itemsToUpdate) {
                    await fetch('/api/inventory/enroute/tracking', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id: item.id, trackingNumber })
                    });
                }
                
                await loadInventory();
                
                // Show tracking saved and prompt for delivery date
                const trackingUrl = `https://www.ups.com/track?tracknum=${trackingNumber}`;
                let html = `<strong>Tracking saved!</strong><br><br>`;
                html += `Tracking #: ${trackingNumber}<br><br>`;
                html += `<a href="${trackingUrl}" target="_blank" style="color:#90EE90; font-weight:bold;">üì¶ Check delivery date on UPS ‚Üí</a><br><br>`;
                html += `<div style="margin-top:10px; padding:10px; background:#1a1a1a; border-radius:6px;">`;
                html += `<span style="color:#ccc;">Enter delivery date from UPS:</span><br>`;
                html += `<div style="display:flex; gap:8px; margin-top:8px;">`;
                html += `<input type="text" id="manualDeliveryDate" placeholder="mm/dd/yy" style="padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; width:100px;">`;
                html += `<button class="action-btn" onclick="saveManualDeliveryDate('${dateKey}')" style="padding:8px 12px;">Save</button>`;
                html += `</div></div>`;
                
                addMessage(html, false);
                
            } catch (error) {
                console.error('Error saving tracking:', error);
                addMessage('Error saving tracking number.', false);
            }
        }
        
        // Save manually entered delivery date
        async function saveManualDeliveryDate(dateKey) {
            const input = document.getElementById('manualDeliveryDate');
            const deliveryDate = input?.value?.trim();
            
            if (!deliveryDate) {
                alert('Please enter a delivery date');
                return;
            }
            
            // Update all items with this date
            const itemsToUpdate = enRouteCoffeeInventory.filter(item => 
                (item.dateOrdered || 'unknown') === dateKey
            );
            
            try {
                for (const item of itemsToUpdate) {
                    await fetch('/api/inventory/enroute/tracking', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            id: item.id, 
                            trackingNumber: item.trackingNumber,
                            manualDeliveryDate: deliveryDate 
                        })
                    });
                }
                
                await loadInventory();
                addMessage(`üì¶ Delivery date saved: ${deliveryDate}`, false);
                addConversationalFollowUp('tracking_updated');
                
            } catch (error) {
                console.error('Error saving delivery date:', error);
                addMessage('Error saving delivery date.', false);
            }
        }
        
        // Open tracking table modal for multiple orders
        function openTrackingModal() {
            const ordersWithoutTracking = getOrdersWithoutTracking();
            
            let html = '';
            ordersWithoutTracking.forEach((order, index) => {
                const items = order.items;
                const itemsList = items.map(i => `${i.weight}lb ${i.name}`).join(', ');
                
                // Format date
                let dateStr = '';
                if (order.dateKey && order.dateKey !== 'unknown') {
                    const date = new Date(order.dateKey);
                    if (!isNaN(date.getTime())) {
                        dateStr = date.toLocaleDateString();
                    }
                }
                
                html += `<div style="background:#1a1a1a; padding:12px; border-radius:8px; margin-bottom:8px;">`;
                html += `<div style="margin-bottom:8px;">`;
                html += `<strong style="color:#90EE90;">${itemsList}</strong>`;
                if (dateStr) {
                    html += `<br><span style="font-size:12px; color:#888;">Ordered: ${dateStr}</span>`;
                }
                html += `</div>`;
                html += `<input type="text" placeholder="Enter tracking number..." style="width:100%; padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" data-tracking-order="${index}" data-date-key="${order.dateKey}">`;
                html += `</div>`;
            });
            
            document.getElementById('trackingOrderList').innerHTML = html;
            document.getElementById('trackingModal').style.display = 'flex';
        }
        
        function closeTrackingModal() {
            document.getElementById('trackingModal').style.display = 'none';
        }
        
        async function saveAllTracking() {
            const inputs = document.querySelectorAll('[data-tracking-order]');
            let updated = 0;
            
            for (const input of inputs) {
                const trackingNumber = input.value.trim();
                const dateKey = input.dataset.dateKey;
                
                if (trackingNumber) {
                    const itemsToUpdate = enRouteCoffeeInventory.filter(item => 
                        (item.dateOrdered || 'unknown') === dateKey
                    );
                    
                    for (const item of itemsToUpdate) {
                        try {
                            await fetch('/api/inventory/enroute/tracking', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ id: item.id, trackingNumber })
                            });
                            updated++;
                        } catch (error) {
                            console.error('Error updating tracking:', error);
                        }
                    }
                }
            }
            
            closeTrackingModal();
            await loadInventory();
            
            if (updated > 0) {
                addMessage(`Tracking updated for ${updated} item(s).`, false);
            }
            addConversationalFollowUp('tracking_updated');
        }
        
        // Mark delivered for a group of items (same order date)
        async function startMarkDeliveredGroup(dateKey) {
            const items = enRouteCoffeeInventory.filter(item => 
                (item.dateOrdered || 'unknown') === dateKey
            );
            
            if (items.length === 0) return;
            
            const itemsList = items.map(i => `${i.weight}lb ${i.name}`).join(', ');
            
            addMessage(`Mark as delivered: ${itemsList}?`, false);
            
            let html = '<div style="margin-top:8px;">Enter your initials to confirm:</div>';
            html += `<div style="display:flex; gap:8px; margin-top:8px;">`;
            html += `<input type="text" id="deliveryInitials" placeholder="Initials" style="width:80px; padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;">`;
            html += `<button class="action-btn" onclick="confirmDeliveryGroup('${dateKey}')" style="padding:8px 12px; background:#4a6741;">Confirm</button>`;
            html += `<button class="action-btn" onclick="addConversationalFollowUp('delivery_cancelled')">Cancel</button>`;
            html += `</div>`;
            
            const messages = chatContainer.querySelectorAll('.message');
            const lastMsg = messages[messages.length - 1];
            if (lastMsg) {
                const content = lastMsg.querySelector('.message-content') || lastMsg;
                content.innerHTML += html;
            }
        }
        
        async function confirmDeliveryGroup(dateKey) {
            const initialsInput = document.getElementById('deliveryInitials');
            const initials = initialsInput?.value?.trim();
            
            if (!initials) {
                alert('Please enter your initials');
                return;
            }
            
            const items = enRouteCoffeeInventory.filter(item => 
                (item.dateOrdered || 'unknown') === dateKey
            );
            
            try {
                for (const item of items) {
                    await fetch('/api/inventory/enroute/deliver', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: item.id,
                            coffeeName: item.name,
                            weight: item.weight,
                            type: item.type,
                            initials: initials
                        })
                    });
                }
                
                await loadInventory();
                const itemsList = items.map(i => `${i.weight}lb ${i.name}`).join(', ');
                addMessage(`Delivered: ${itemsList} (confirmed by ${initials})`, false);
                addConversationalFollowUp('delivery_confirmed');
            } catch (error) {
                console.error('Error marking delivered:', error);
                addMessage('Error marking as delivered.', false);
            }
        }
        
        function promptAddTracking(itemId) {
            addMessage('Enter the UPS tracking number:', false);
            window.pendingEnRouteEdit = itemId;
            userInput.placeholder = 'Enter tracking number...';
            userInput.focus();
        }
        
        function startMarkDelivered(itemId, itemName, weight) {
            addMessage(`Mark ${itemName} (${weight}lb) as delivered?<br><br>Please enter your initials to confirm:`, false);
            window.pendingDeliveryConfirm = { itemId, itemName, weight };
            userInput.placeholder = 'Enter your initials...';
            userInput.focus();
        }
        
        async function confirmDeliveryWithInitials(initials) {
            const pending = window.pendingDeliveryConfirm;
            if (!pending) return;
            
            window.pendingDeliveryConfirm = null;
            
            try {
                const response = await fetch('/api/inventory/enroute/deliver', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: pending.itemId, confirmedBy: initials })
                });
                
                const data = await response.json();
                await loadInventory();
                
                addMessage(`${data.message} (Confirmed by: ${initials.toUpperCase()})`, false);
                addConversationalFollowUp('delivery_confirmed');
                
            } catch (error) {
                console.error('Error:', error);
                addMessage('Error marking as delivered: ' + error.message, false);
            }
        }
        
        async function confirmDelivery(itemId) {
            // This is now handled by startMarkDelivered + initials flow
            startMarkDelivered(itemId, '', 0);
        }
        
        function cancelDelivery() {
            window.pendingDeliveryConfirm = null;
            addMessage('Cancelled.', false);
            addConversationalFollowUp('cancelled');
        }

        async function editEnRouteItem(itemId) {
            promptAddTracking(itemId);
        }
        
        async function markDeliveredChat(itemId, itemName, weight) {
            startMarkDelivered(itemId, itemName, weight);
        }

        // Keep modal functions for backward compatibility but they're less used now
        function renderEnRouteModal() {
            const listDiv = document.getElementById('enRouteList');
            
            if (enRouteCoffeeInventory.length === 0) {
                listDiv.innerHTML = '<div style="color:#888; text-align:center; padding:30px;">No coffee currently en route.</div>';
                return;
            }
            
            let html = '';
            enRouteCoffeeInventory.forEach((item, index) => {
                // Use dateOrdered field - if already in mm/dd/yy format, show directly
                let orderDateStr = item.dateOrdered || '';
                if (orderDateStr && !orderDateStr.match(/^\d{2}\/\d{2}\/\d{2}$/)) {
                    // Try to parse and format if not in mm/dd/yy format
                    const orderDate = new Date(orderDateStr);
                    if (!isNaN(orderDate.getTime())) {
                        const m = String(orderDate.getMonth() + 1).padStart(2, '0');
                        const d = String(orderDate.getDate()).padStart(2, '0');
                        const y = String(orderDate.getFullYear()).slice(-2);
                        orderDateStr = `${m}/${d}/${y}`;
                    }
                }
                
                html += `<div style="background:#1a1a1a; padding:15px; border-radius:8px; margin-bottom:10px;">`;
                html += `<div style="margin-bottom:10px;">`;
                html += `<strong style="color:#90EE90; font-size:16px;">${item.name}</strong> - ${item.weight}lb<br>`;
                
                // Show order date
                if (orderDateStr) {
                    html += `<span style="font-size:12px; color:#888;">Ordered: ${orderDateStr}</span>`;
                }
                
                // Show estimated delivery if available
                if (item.estimatedDelivery) {
                    html += `<div style="margin-top:8px; padding:8px; background:#2a3a2a; border-radius:4px;">`;
                    html += `<span style="color:#90EE90; font-weight:bold;">üì¶ Est. Delivery: ${item.estimatedDelivery}</span>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
                
                // Tracking input and buttons
                html += `<div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">`;
                html += `<input type="text" placeholder="Enter tracking number..." value="${item.trackingNumber || ''}" style="flex:1; min-width:150px; padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px;" id="tracking-${item.id}">`;
                html += `<button onclick="updateTracking('${item.id}')" style="background:#41576a; border:none; color:white; padding:8px 12px; border-radius:4px; cursor:pointer;">${item.trackingNumber ? 'Update' : 'Save'}</button>`;
                html += `</div>`;
                
                // If tracking exists, show UPS link and delivery date input
                if (item.trackingNumber) {
                    html += `<div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">`;
                    html += `<a href="https://www.ups.com/track?tracknum=${item.trackingNumber}" target="_blank" style="background:#6b5b3b; color:white; padding:8px 12px; border-radius:4px; text-decoration:none; font-size:13px;">üì¶ Track on UPS</a>`;
                    
                    // Delivery date input
                    html += `<input type="text" placeholder="Delivery date" value="${item.estimatedDelivery || ''}" style="width:100px; padding:8px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:4px; font-size:13px;" id="delivery-${item.id}">`;
                    html += `<button onclick="saveDeliveryDate('${item.id}')" style="background:#4a5741; border:none; color:white; padding:8px 10px; border-radius:4px; cursor:pointer; font-size:13px;">Save</button>`;
                    html += `</div>`;
                }
                
                html += `<div style="margin-top:8px;">`;
                html += `<button onclick="markDelivered('${item.id}')" style="background:#4a6741; border:none; color:white; padding:8px 12px; border-radius:4px; cursor:pointer;">Mark Delivered</button>`;
                html += `</div>`;
                html += `</div>`;
            });
            
            listDiv.innerHTML = html;
        }
        
        // Save delivery date from modal
        async function saveDeliveryDate(itemId) {
            const input = document.getElementById(`delivery-${itemId}`);
            const deliveryDate = input?.value?.trim();
            const item = enRouteCoffeeInventory.find(i => i.id === itemId);
            
            if (!deliveryDate) {
                alert('Please enter a delivery date');
                return;
            }
            
            try {
                await fetch('/api/inventory/enroute/tracking', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        id: itemId, 
                        trackingNumber: item?.trackingNumber || '',
                        manualDeliveryDate: deliveryDate 
                    })
                });
                
                await loadInventory();
                renderEnRouteModal();
                
            } catch (error) {
                console.error('Error saving delivery date:', error);
                alert('Error saving delivery date');
            }
        }

        async function updateTracking(itemId) {
            const trackingInput = document.getElementById(`tracking-${itemId}`);
            const trackingNumber = trackingInput.value;
            
            if (!trackingNumber) {
                alert('Please enter a tracking number');
                return;
            }
            
            // Show loading state
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Saving...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/inventory/enroute/tracking', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: itemId, trackingNumber })
                });
                
                const data = await response.json();
                
                await loadInventory();
                renderEnRouteModal();
                
                // Show delivery info in alert
                if (data.message) {
                    alert(data.message);
                }
                
            } catch (error) {
                console.error('Error updating tracking:', error);
                alert('Error updating tracking: ' + error.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function markDelivered(itemId) {
            if (!confirm('Mark this order as delivered? It will be added to your roasted coffee inventory.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/inventory/enroute/deliver', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: itemId })
                });
                
                const data = await response.json();
                
                await loadInventory();
                renderEnRouteModal();
                
                // Show confirmation
                const welcomeMsg = document.querySelector('.welcome-message');
                if (!welcomeMsg) {
                    addMessage(`${data.message}`, false);
                }
                
            } catch (error) {
                console.error('Error marking delivered:', error);
                alert('Error marking delivered: ' + error.message);
            }
        }

        function closeEnRouteModal() {
            document.getElementById('enRouteModal').style.display = 'none';
        }

        // Load inventory on page load
        loadInventory();

        voiceBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        async function startRecording() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${wsProtocol}//${window.location.host}`);

                ws.onopen = () => {
                    audioContext = new AudioContext({ sampleRate: 16000 });
                    const source = audioContext.createMediaStreamSource(mediaStream);
                    processor = audioContext.createScriptProcessor(4096, 1, 1);

                    processor.onaudioprocess = (e) => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            const pcmData = new Int16Array(inputData.length);
                            for (let i = 0; i < inputData.length; i++) {
                                pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                            }
                            ws.send(pcmData.buffer);
                        }
                    };

                    source.connect(processor);
                    processor.connect(audioContext.destination);

                    isRecording = true;
                    voiceBtn.classList.add('recording');
                    micIndicator.classList.add('recording');
                    micStatus.textContent = 'üî¥ Recording...';
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'transcript') {
                        if (data.is_final) {
                            // Clear partial indicator
                            micStatus.textContent = 'üî¥ Recording...';
                            partialTranscript = '';
                            insertTranscriptAtCursor(data.text);
                        } else {
                            // Show partial transcript in mic status and inline
                            partialTranscript = data.text;
                            const partialText = data.text.length > 30 
                                ? '...' + data.text.slice(-30) 
                                : data.text;
                            micStatus.textContent = 'üé§ ' + partialText;
                            
                            // Show partial inline (grayed out) at cursor position
                            showPartialInline(data.text);
                        }
                    }
                };

                ws.onerror = () => stopRecording();

            } catch (error) {
                console.error('Recording error:', error);
                alert('Could not access microphone');
            }
        }
        
        // Track cursor position and selection for dictation editing
        let lastCursorPosition = null;
        let lastSelectionStart = null;
        let lastSelectionEnd = null;
        
        userInput.addEventListener('click', updateCursorPosition);
        userInput.addEventListener('keyup', updateCursorPosition);
        userInput.addEventListener('select', updateCursorPosition);
        userInput.addEventListener('mouseup', updateCursorPosition);
        
        function updateCursorPosition() {
            lastCursorPosition = userInput.selectionStart;
            lastSelectionStart = userInput.selectionStart;
            lastSelectionEnd = userInput.selectionEnd;
        }
        
        function insertTranscriptAtCursor(text) {
            const currentText = userInput.value;
            const hasSelection = lastSelectionStart !== null && 
                                 lastSelectionEnd !== null && 
                                 lastSelectionStart !== lastSelectionEnd;
            
            if (hasSelection) {
                // Replace selected text with spoken text
                const before = currentText.substring(0, lastSelectionStart);
                const after = currentText.substring(lastSelectionEnd);
                userInput.value = before + text + after;
                
                // Move cursor to end of inserted text
                const newPosition = lastSelectionStart + text.length;
                userInput.setSelectionRange(newPosition, newPosition);
                lastCursorPosition = newPosition;
                lastSelectionStart = newPosition;
                lastSelectionEnd = newPosition;
                
            } else if (lastCursorPosition !== null && lastCursorPosition < currentText.length) {
                // Insert at cursor position (middle of text)
                const before = currentText.substring(0, lastCursorPosition);
                const after = currentText.substring(lastCursorPosition);
                
                // Add space before if needed
                const needsSpaceBefore = before.length > 0 && !before.endsWith(' ') && !before.endsWith('\n');
                // Add space after if needed  
                const needsSpaceAfter = after.length > 0 && !after.startsWith(' ') && !after.startsWith('\n');
                
                const insertText = (needsSpaceBefore ? ' ' : '') + text + (needsSpaceAfter ? ' ' : '');
                userInput.value = before + insertText + after;
                
                // Move cursor to end of inserted text
                const newPosition = before.length + insertText.length;
                userInput.setSelectionRange(newPosition, newPosition);
                lastCursorPosition = newPosition;
                lastSelectionStart = newPosition;
                lastSelectionEnd = newPosition;
                
            } else {
                // Append to end (default behavior)
                userInput.value = currentText + (currentText ? ' ' : '') + text;
                lastCursorPosition = userInput.value.length;
                lastSelectionStart = lastCursorPosition;
                lastSelectionEnd = lastCursorPosition;
            }
            
            // Adjust textarea height
            userInput.style.height = 'auto';
            userInput.style.height = Math.min(userInput.scrollHeight, 240) + 'px';
            
            // Focus the input to show cursor position
            userInput.focus();
        }
        
        function showPartialInline(partialText) {
            // For now, partial is shown in mic status bar
            // Could enhance with overlay display in future
            // The textarea keeps the saved text, partial shows in status
        }

        function stopRecording() {
            isRecording = false;
            voiceBtn.classList.remove('recording');
            micIndicator.classList.remove('recording');
            micStatus.textContent = 'Ready';
            
            // Clear partial transcript state
            partialTranscript = '';
            savedTextBeforePartial = '';

            if (processor) processor.disconnect();
            if (audioContext) audioContext.close();
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (ws) ws.close();

            processor = null;
            audioContext = null;
            mediaStream = null;
            ws = null;
        }

        function addMessage(text, isUser) {
            const welcomeMsg = chatContainer.querySelector('.welcome-message');
            if (welcomeMsg) welcomeMsg.remove();

            // Before adding a new assistant message, deactivate buttons in all previous assistant messages
            if (!isUser) {
                const previousMessages = chatContainer.querySelectorAll('.message.assistant');
                previousMessages.forEach(msg => {
                    const buttons = msg.querySelectorAll('.action-btn:not([disabled])');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.background = '#2a2a2a';
                        btn.style.color = '#555';
                        btn.style.cursor = 'not-allowed';
                        btn.onclick = null;
                    });
                });
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + (isUser ? 'user' : 'assistant');
            
            const content = document.createElement('div');
            content.className = 'message-content';
            content.innerHTML = text;
            
            messageDiv.appendChild(content);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function processMessage(message, conversationState) {
            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: message, 
                        context: 'inventory management',
                        conversationState: conversationState || window.currentConversationState || 'none'
                    })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    console.error('API error:', data);
                    setTimeout(() => {
                        addConversationalFollowUp('unclear_request');
                    }, 300);
                    return "Sorry, I didn't get that.";
                }
                
                // Handle action-based responses - trigger appropriate functions
                if (data.action === 'check_inventory') {
                    // Remove the loading message before calling checkCurrentInventory
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    checkCurrentInventory();
                    return null; // Don't return a message, function handles it
                }
                
                if (data.action === 'manage_inventory') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    openManageInventory();
                    return null;
                }
                
                if (data.action === 'manage_customers') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    openManageCustomers();
                    return null;
                }
                
                if (data.action === 'order_roast') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    startRoastOrder();
                    return null;
                }
                
                if (data.action === 'view_en_route') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    viewEnRoute();
                    return null;
                }
                
                if (data.action === 'start_invoice') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    startInvoice();
                    return null;
                }
                
                if (data.action === 'manage_retail') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    manageRetail();
                    return null;
                }
                
                if (data.action === 'show_todo') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    showToDo();
                    return null;
                }
                
                if (data.action === 'show_forecast') {
                    const messages = chatContainer.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                    showForecast();
                    return null;
                }
                
                // Check if this is an invoice action
                if (data.action === 'create_invoice' && data.invoiceDetails) {
                    // Show the "Processing now..." message first
                    const processingHtml = '<div style="white-space: pre-wrap;">' + data.response + '</div>';
                    
                    // Actually generate the invoice
                    const invoiceResult = await generateInvoice(data.invoiceDetails);
                    
                    // Add follow-up after invoice generation (but not if there was an error)
                    if (!invoiceResult.includes("Sorry") && !invoiceResult.includes("error")) {
                        setTimeout(() => {
                            addConversationalFollowUp('invoice_generated');
                        }, 500);
                    }
                    
                    return processingHtml + '<br>' + invoiceResult;
                }
                
                // Check if user typed "yes" to confirm adding customer
                if (data.action === 'confirm_add_customer' && window.pendingNewCustomer) {
                    const pending = window.pendingNewCustomer;
                    window.pendingNewCustomer = null;
                    window.currentConversationState = 'none';
                    
                    try {
                        // Add the new customer
                        const addResponse = await fetch('/api/customers/add', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: pending.customer })
                        });
                        
                        if (!addResponse.ok) {
                            const error = await addResponse.json();
                            return '<p style="color: #ff6b6b;">' + error.error + '</p>';
                        }
                        
                        const addData = await addResponse.json();
                        let html = '' + addData.message + '<br><br>';
                        
                        // Generate the invoice
                        const invoiceDetails = `${pending.customer} ${pending.quantity} ${pending.unit} ${pending.product}`;
                        const invoiceResult = await generateInvoice(invoiceDetails);
                        return html + invoiceResult;
                        
                    } catch (error) {
                        console.error('Error:', error);
                        return '<p style="color: #ff6b6b;">Error adding customer.</p>';
                    }
                }
                
                // Check if asking about new customer
                if (data.action === 'confirm_new_customer' && data.pendingInvoice) {
                    // Store pending invoice for later
                    window.pendingNewCustomer = data.pendingInvoice;
                    window.currentConversationState = 'waiting_for_new_customer_confirmation';
                    let html = '<div style="white-space: pre-wrap;">' + data.response + '</div>';
                    html += '<div class="response-buttons" style="margin-top: 10px;">';
                    html += '<button class="action-btn" onclick="confirmNewCustomer(true)">Yes, add them</button>';
                    html += '<button class="action-btn" onclick="confirmNewCustomer(false)">No, cancel</button>';
                    html += '</div>';
                    return html;
                }
                
                // Format the response - use simple format for short/completed responses
                let html;
                if (data.showFollowUp || data.action === 'declined' || data.action === 'check_inventory') {
                    html = formatSimpleResponse(data.response);
                } else {
                    html = formatResponseHTML(data.response);
                }
                
                // Check if we should show follow-up menu
                if (data.showFollowUp) {
                    window.currentConversationState = 'none';
                    // Add follow-up after a short delay
                    setTimeout(() => {
                        addConversationalFollowUp(data.action || 'completed');
                    }, 300);
                }
                
                // For unclear responses, just show buttons (no additional message)
                if (data.action === 'unclear') {
                    window.currentConversationState = 'none';
                    setTimeout(() => {
                        addFollowUpButtons();
                    }, 300);
                }
                
                return html;
                
            } catch (error) {
                console.error('Error:', error);
                // Trigger follow-up on next tick
                setTimeout(() => {
                    addConversationalFollowUp('unclear_request');
                }, 300);
                return "Sorry, I didn't get that.";
            }
        }
        
        async function confirmNewCustomer(confirm) {
            window.currentConversationState = 'none';
            
            if (!confirm) {
                // Send "no" through the API to get proper response
                addMessage('No', true);
                addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                
                const response = await processMessage('no, cancel', 'waiting_for_new_customer_confirmation');
                const messages = chatContainer.querySelectorAll('.message');
                messages[messages.length - 1].remove();
                if (response !== null) addMessage(response, false);
                
                window.pendingNewCustomer = null;
                return;
            }
            
            if (!window.pendingNewCustomer) {
                addMessage('No pending customer to add.', false);
                return;
            }
            
            addMessage('Yes, add them', true);
            
            // Ask for 3-letter code
            const customerName = window.pendingNewCustomer.customer;
            addMessage(`Three letter code for "${customerName}"?`, false);
            
            // Set state to wait for code input
            window.waitingForCustomerCode = true;
        }
        
        async function addCustomerWithCode(code) {
            if (!window.pendingNewCustomer) {
                addMessage('No pending customer to add.', false);
                return;
            }
            
            const pending = window.pendingNewCustomer;
            window.pendingNewCustomer = null;
            window.waitingForCustomerCode = false;
            
            // Add the new customer with code
            try {
                const addResponse = await fetch('/api/customers/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: pending.customer, code: code })
                });
                
                if (!addResponse.ok) {
                    const error = await addResponse.json();
                    addMessage('<p style="color: #ff6b6b;">' + error.error + '</p>', false);
                    return;
                }
                
                const addData = await addResponse.json();
                addMessage('' + addData.message, false);
                
                // Now generate the invoice
                addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                
                const invoiceDetails = `${pending.customer} ${pending.quantity} ${pending.unit} ${pending.product}`;
                const invoiceResult = await generateInvoice(invoiceDetails);
                
                const messages = chatContainer.querySelectorAll('.message');
                messages[messages.length - 1].remove();
                addMessage(invoiceResult, false);
                
            } catch (error) {
                console.error('Error:', error);
                addMessage('<p style="color: #ff6b6b;">Error adding customer.</p>', false);
            }
        }

        function formatResponseHTML(responseText) {
            currentResponseText = responseText;
            
            let html = '<div style="white-space: pre-wrap;">' + responseText + '</div>';
            
            html += '<div class="response-buttons">';
            html += '<button class="action-btn" onclick="copyResponse(this)">üìã Copy</button>';
            html += '<button class="action-btn" onclick="openEmailModal()" ' + (googleConnected ? '' : 'disabled title="Connect Google first"') + '>üìß Email</button>';
            html += '<button class="action-btn" onclick="updateSheet()" ' + (googleConnected ? '' : 'disabled title="Connect Google first"') + '>üìä Update Sheet</button>';
            html += '</div>';
            
            return html;
        }
        
        function formatSimpleResponse(responseText) {
            // For short/simple responses without action buttons
            return '<div style="white-space: pre-wrap;">' + responseText + '</div>';
        }

        function copyResponse(button) {
            navigator.clipboard.writeText(currentResponseText).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('success');
                setTimeout(() => {
                    button.textContent = 'üìã Copy';
                    button.classList.remove('success');
                }, 2000);
            });
        }

        function openEmailModal() {
            if (!googleConnected) {
                alert('Please connect Google first.');
                return;
            }
            document.getElementById('emailBody').value = currentResponseText;
            // Hide attachment indicator for non-invoice emails
            document.getElementById('attachmentIndicator').style.display = 'none';
            document.getElementById('emailModal').classList.add('active');
        }

        function closeEmailModal() {
            document.getElementById('emailModal').classList.remove('active');
            // Clear attachment data
            document.getElementById('attachmentIndicator').style.display = 'none';
            const modal = document.getElementById('emailModal');
            delete modal.dataset.pdfUrl;
            delete modal.dataset.invoiceNumber;
        }

        async function sendEmail() {
            const to = document.getElementById('emailTo').value.trim();
            const subject = document.getElementById('emailSubject').value.trim();
            const body = document.getElementById('emailBody').value;
            const btn = document.getElementById('sendEmailBtn');
            const modal = document.getElementById('emailModal');
            
            // Get attachment info if available
            const pdfUrl = modal.dataset.pdfUrl || null;
            const invoiceNumber = modal.dataset.invoiceNumber || null;
            const customerName = modal.dataset.customerName || null;
            const originalEmails = modal.dataset.originalEmails || '';
            
            if (!to) {
                alert('Please enter a recipient email.');
                return;
            }
            
            // Create the draft first
            const success = await proceedWithEmailDraft({ to, subject, body, pdfUrl, invoiceNumber });
            
            // If draft was created and emails have changed, ask about saving
            if (success && customerName && to !== originalEmails) {
                // Parse the new emails
                const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                const newEmails = to.match(emailRegex) || [];
                const emailCount = newEmails.length;
                
                const emailText = emailCount > 1 ? 'these emails' : 'this email';
                addMessage(`Do you want to save ${emailText} for future ${customerName} invoices? (${to})`, false);
                
                // Store pending email update info
                window.pendingEmailUpdate = {
                    customerName,
                    newEmails: to
                };
                window.waitingForEmailUpdateConfirmation = true;
            }
        }
        
        async function proceedWithEmailDraft(emailData) {
            const btn = document.getElementById('sendEmailBtn');
            const modal = document.getElementById('emailModal');
            
            btn.disabled = true;
            btn.textContent = 'Creating...';
            
            try {
                // Build request body
                const requestBody = { to: emailData.to, subject: emailData.subject, body: emailData.body };
                
                // If this is an invoice email, include the PDF path
                if (emailData.pdfUrl && emailData.invoiceNumber) {
                    // Convert URL to file path (e.g., /invoices/C-ARC-1000.pdf -> public/invoices/C-ARC-1000.pdf)
                    requestBody.attachmentPath = 'public' + emailData.pdfUrl;
                    requestBody.attachmentName = emailData.invoiceNumber + '.pdf';
                }
                
                const response = await fetch('/api/gmail/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    addMessage('' + (data.message || 'Draft created! Check your Gmail drafts folder.'), false);
                    closeEmailModal();
                    // Clear the attachment data
                    delete modal.dataset.pdfUrl;
                    delete modal.dataset.invoiceNumber;
                    delete modal.dataset.customerName;
                    delete modal.dataset.originalEmails;
                    return true;
                } else if (response.status === 401) {
                    handleGoogleDisconnected();
                    const data = await response.json();
                    addMessage(`<div style="color: #dc3545;">‚ö†Ô∏è ${data.error || 'Google account not connected.'}</div>
                        <div style="margin-top: 8px;">Please connect your Google account to send emails.</div>
                        <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('email')">Connect Google Account</button>`, false);
                    closeEmailModal();
                    return false;
                } else {
                    const data = await response.json();
                    addMessage('Failed: ' + (data.error || 'Unknown error'), false);
                    return false;
                }
            } catch (error) {
                addMessage('Error creating draft', false);
                return false;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Draft';
            }
        }
        
        async function handleEmailUpdateResponse(userMessage) {
            // Use Gemini to interpret the response
            try {
                const response = await fetch('/api/interpret-confirmation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessage })
                });
                
                const data = await response.json();
                
                if (data.confirmed === true) {
                    handleEmailUpdateConfirmation(true);
                } else if (data.confirmed === false) {
                    handleEmailUpdateConfirmation(false);
                } else {
                    addMessage('I didn\'t quite catch that. Do you want to save this email for future invoices? (yes/no)', false);
                }
            } catch (error) {
                console.error('Error interpreting response:', error);
                // Fallback to simple check
                const lowerMsg = userMessage.toLowerCase();
                if (lowerMsg.includes('yes') || lowerMsg.includes('sure') || lowerMsg.includes('ok') || lowerMsg.includes('yep') || lowerMsg.includes('yeah')) {
                    handleEmailUpdateConfirmation(true);
                } else if (lowerMsg.includes('no') || lowerMsg.includes('nope') || lowerMsg.includes('cancel')) {
                    handleEmailUpdateConfirmation(false);
                } else {
                    addMessage('I didn\'t quite catch that. Do you want to save this email for future invoices? (yes/no)', false);
                }
            }
        }
        
        async function handleEmailUpdateConfirmation(confirmed) {
            window.waitingForEmailUpdateConfirmation = false;
            const pending = window.pendingEmailUpdate;
            
            if (!pending) return;
            
            if (confirmed) {
                // Update the customer's email in the directory
                try {
                    const response = await fetch('/api/customers/emails', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            customerName: pending.customerName,
                            emailsInput: pending.newEmails
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        addMessage(`Updated email(s) for ${pending.customerName}: ${data.emails.join(', ')}`, false);
                    }
                } catch (error) {
                    console.error('Error updating emails:', error);
                    addMessage('Error saving emails.', false);
                }
            } else {
                addMessage('No problem, email not saved to directory.', false);
            }
            
            window.pendingEmailUpdate = null;
            
            // Add follow-up
            setTimeout(() => {
                addConversationalFollowUp('email_updated');
            }, 500);
        }

        async function updateSheet() {
            if (!googleConnected) {
                alert('Please connect Google first.');
                return;
            }
            alert('Sheet update feature - coming soon!');
        }

        function sendMessage() {
            if (isRecording) stopRecording();
            
            const message = userInput.value.trim();
            if (!message) return;

            addMessage(message, true);
            
            userInput.value = '';
            userInput.style.height = 'auto';
            userInput.placeholder = 'Describe what you want to do‚Ä¶';
            
            // Check for cancel/topic change phrases
            const lowerMsg = message.toLowerCase();
            const cancelPhrases = ['never mind', 'nevermind', 'cancel', 'nope', 'forget it', 'stop', 'actually', 'wait', 'hold on'];
            const topicChangePhrases = ['inventory', 'invoice', 'en route', 'check', 'help me', 'what can you', 'show me', 'can you help'];
            const isCanceling = cancelPhrases.some(p => lowerMsg.includes(p));
            const isChangingTopic = topicChangePhrases.some(p => lowerMsg.includes(p));
            const wantsToSwitch = isCanceling || isChangingTopic;
            
            // Direct command detection - handle common phrases without LLM
            const directCommands = {
                'manage inventory': () => { openManageInventory(); return true; },
                'edit inventory': () => { openManageInventory(); return true; },
                'manage customers': () => { openManageCustomers(); return true; },
                'customers': () => { openManageCustomers(); return true; },
                'to do': () => { showToDo(); return true; },
                'todo': () => { showToDo(); return true; },
                'check inventory': () => { checkCurrentInventory(); return true; },
                'view inventory': () => { checkCurrentInventory(); return true; },
                'order roast': () => { startRoastOrder(); return true; },
                'roast order': () => { startRoastOrder(); return true; },
                'en route': () => { viewEnRoute(); return true; },
                'generate invoice': () => { startInvoice(); return true; },
                'create invoice': () => { startInvoice(); return true; },
                'new invoice': () => { startInvoice(); return true; },
                'manage retail': () => { manageRetail(); return true; },
                'retail': () => { manageRetail(); return true; },
                'forecast': () => { showForecast(); return true; },
            };
            
            // Check for direct command match
            for (const [cmd, action] of Object.entries(directCommands)) {
                if (lowerMsg === cmd || lowerMsg === cmd + '?' || lowerMsg === cmd + '.') {
                    action();
                    return;
                }
            }
            
            // Handle pure cancel phrases - just show follow-up options
            const pureCancelPhrases = ['never mind', 'nevermind', 'cancel', 'forget it', 'nope'];
            if (pureCancelPhrases.some(p => lowerMsg === p || lowerMsg === p + '.' || lowerMsg === p + '!')) {
                // Clear any pending states
                waitingForRoastOrder = false;
                window.waitingForOrderConfirmation = false;
                window.pendingClarification = null;
                pendingRoastOrder = [];
                
                addMessage('No problem! What would you like to do?', false);
                setTimeout(() => {
                    addFollowUpButtons();
                }, 100);
                return;
            }
            
            // Check if there's a pending invoice that hasn't been confirmed
            if (window.pendingInvoiceData && !window.pendingInvoiceWarningShown) {
                // Check if user is trying to correct the invoice (mentions same customer or product)
                const pendingCustomer = window.pendingInvoiceData.customer?.toLowerCase() || '';
                const pendingProducts = window.pendingInvoiceData.items?.map(i => i.description?.toLowerCase() || '') || [];
                const mentionsInvoice = lowerMsg.includes(pendingCustomer) || 
                                        pendingProducts.some(p => lowerMsg.includes(p.replace(' (units in lbs)', '').toLowerCase())) ||
                                        lowerMsg.includes('confirm') || lowerMsg.includes('yes');
                
                // If not correcting and not confirming, warn user
                if (!mentionsInvoice) {
                    window.pendingInvoiceWarningShown = true;
                    window.pendingMessageAfterWarning = message;
                    
                    let html = `<div style="color: #f0ad4e; margin-bottom: 12px;">‚ö†Ô∏è You have an unconfirmed invoice (${window.pendingInvoiceData.invoiceNumber}) for ${window.pendingInvoiceData.customer}.</div>`;
                    html += `<div style="margin-bottom: 12px;">Are you sure you want to move on without confirming it?</div>`;
                    html += `<div style="display: flex; gap: 8px;">`;
                    html += `<button class="action-btn" onclick="proceedWithoutInvoice()">Yes, move on</button>`;
                    html += `<button class="action-btn" style="background:#28a745;color:white;" onclick="reshowPendingInvoice()">No, show invoice</button>`;
                    html += `</div>`;
                    
                    addMessage(html, false);
                    return;
                }
            }
            
            // If user confirmed they want to move on after warning
            if (window.pendingInvoiceWarningShown && (lowerMsg === 'yes' || lowerMsg === 'yes, move on' || lowerMsg.includes('move on'))) {
                window.pendingInvoiceData = null;
                window.pendingInvoiceWarningShown = false;
                const originalMessage = window.pendingMessageAfterWarning;
                window.pendingMessageAfterWarning = null;
                
                if (originalMessage) {
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(originalMessage).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
            }

            // Check if we're waiting for order confirmation (user can modify amounts here)
            if (window.waitingForOrderConfirmation) {
                const yesResponses = ['yes', 'yeah', 'yep', 'confirm', 'ok', 'sure', 'looks good', 'good', 'correct'];
                if (yesResponses.some(y => lowerMsg === y || lowerMsg.startsWith(y + ','))) {
                    confirmDefaultOrder();
                    return;
                }
                if (isCanceling && !isChangingTopic) {
                    // Pure cancel - just exit and show follow-up
                    window.waitingForOrderConfirmation = false;
                    pendingRoastOrder = [];
                    addMessage('Order cancelled. What would you like to do?', false);
                    setTimeout(() => addFollowUpButtons(), 100);
                    return;
                }
                if (wantsToSwitch) {
                    window.waitingForOrderConfirmation = false;
                    pendingRoastOrder = [];
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                // User wants to modify the order - parse their request
                modifyRoastOrder(message);
                return;
            }

            // Check if we're waiting for roast order input
            if (waitingForRoastOrder) {
                if (isCanceling && !isChangingTopic) {
                    // Pure cancel - just exit and show follow-up
                    waitingForRoastOrder = false;
                    window.pendingClarification = null;
                    addMessage('No problem! What would you like to do?', false);
                    setTimeout(() => addFollowUpButtons(), 100);
                    return;
                }
                if (wantsToSwitch) {
                    waitingForRoastOrder = false;
                    window.pendingClarification = null;
                    // Route to normal processing
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                waitingForRoastOrder = false;
                parseRoastOrder(message);
                return;
            }
            
            // Check if we're waiting for delivery confirmation initials
            if (window.pendingDeliveryConfirm) {
                if (wantsToSwitch) {
                    window.pendingDeliveryConfirm = null;
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                confirmDeliveryWithInitials(message);
                return;
            }
            
            // Check if we're waiting for en route tracking edit
            if (window.pendingEnRouteEdit) {
                if (wantsToSwitch) {
                    window.pendingEnRouteEdit = null;
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                const itemId = window.pendingEnRouteEdit;
                window.pendingEnRouteEdit = null;
                updateTrackingChat(itemId, message);
                return;
            }

            // Check if we're waiting for customer code
            if (window.waitingForCustomerCode) {
                if (wantsToSwitch) {
                    window.waitingForCustomerCode = false;
                    window.pendingNewCustomerName = null;
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                // Validate and process the 3-letter code
                const code = message.toUpperCase().replace(/[^A-Z]/g, '');
                if (code.length !== 3) {
                    addMessage('Please enter exactly 3 letters (e.g., "ABC")', false);
                    return;
                }
                addCustomerWithCode(code);
                return;
            }
            
            // Check if we're waiting for customer email
            if (window.waitingForCustomerEmail) {
                if (wantsToSwitch) {
                    window.waitingForCustomerEmail = false;
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                processCustomerEmail(message);
                return;
            }
            
            // Check if we're waiting for email update confirmation
            if (window.waitingForEmailUpdateConfirmation) {
                if (wantsToSwitch) {
                    window.waitingForEmailUpdateConfirmation = false;
                    window.pendingEmailUpdate = null;
                    addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                    processMessage(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) addMessage(response, false);
                    });
                    return;
                }
                handleEmailUpdateResponse(message);
                return;
            }

            addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);

            if (pendingInvoice) {
                // Already checked wantsToSwitch above
                if (wantsToSwitch) {
                    pendingInvoice = false;
                    // Route to normal processing
                    processMessage(message).then(response => {
                        // Only remove loader if processMessage didn't handle it (response is not null)
                        if (response !== null) {
                            const messages = chatContainer.querySelectorAll('.message');
                            messages[messages.length - 1].remove();
                            addMessage(response, false);
                        }
                    });
                } else {
                    pendingInvoice = false;
                    generateInvoice(message).then(response => {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        if (response !== null) {
                            addMessage(response, false);
                        }
                    });
                }
            } else {
                processMessage(message).then(response => {
                    // Only remove loader if processMessage didn't handle it (response is not null)
                    if (response !== null) {
                        const messages = chatContainer.querySelectorAll('.message');
                        messages[messages.length - 1].remove();
                        addMessage(response, false);
                    }
                });
            }
        }
        
        async function updateTrackingChat(itemId, trackingNumber) {
            try {
                await fetch('/api/inventory/enroute/tracking', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: itemId, trackingNumber })
                });
                
                await loadInventory();
                addMessage(`Tracking updated to: ${trackingNumber}`, false);
                addConversationalFollowUp('tracking_updated');
                
            } catch (error) {
                console.error('Error updating tracking:', error);
                addMessage('Error updating tracking: ' + error.message, false);
            }
        }

        async function generateInvoice(details) {
            try {
                const response = await fetch('/api/invoice/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ details })
                });

                const data = await response.json();
                
                // Handle Google not connected - show specific message
                if (response.status === 401) {
                    handleGoogleDisconnected();
                    return `<div style="color: #dc3545;">‚ö†Ô∏è ${data.error || 'Google account not connected.'}</div>
                            <div style="margin-top: 8px;">Please connect your Google account to generate invoices.</div>
                            <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('invoice')">Connect Google Account</button>`;
                }
                
                // Handle conversational fallback when parsing fails
                if (data.success === false) {
                    if (data.action === 'unclear') {
                        setTimeout(() => {
                            addFollowUpButtons();
                        }, 300);
                    }
                    return data.error || "Sorry, I didn't get that.";
                }
                
                if (!response.ok) {
                    throw new Error(data.error || 'Invoice generation failed');
                }
                
                return formatInvoiceResponse(data);
                
            } catch (error) {
                console.error('Error:', error);
                // Check if it's a connection error
                if (error.message && error.message.includes('Google')) {
                    return `<div style="color: #dc3545;">‚ö†Ô∏è ${error.message}</div>
                            <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('invoice')">Connect Google Account</button>`;
                }
                setTimeout(() => {
                    addFollowUpButtons();
                }, 300);
                return "Sorry, I didn't get that.";
            }
        }

        function formatInvoiceResponse(data) {
            // Store invoice data for confirmation
            window.pendingInvoiceData = {
                invoiceNumber: data.invoiceNumber,
                date: data.date,
                total: data.total,
                pdfUrl: data.pdfUrl,
                customer: data.customer,
                items: data.items  // Store items for inventory deduction
            };
            
            let html = '<div>';
            html += '<strong>üßæ Invoice Generated!</strong><br><br>';
            html += '<strong>Invoice #:</strong> ' + data.invoiceNumber + '<br>';
            html += '<strong>Customer:</strong> ' + data.customer + '<br>';
            
            // Display detailed line items
            if (data.items && data.items.length > 0) {
                html += '<strong>Items:</strong><br>';
                data.items.forEach(item => {
                    html += '- ' + item.quantity + ' lbs ' + item.description.replace(' (units in lbs)', '') + ' @ $' + item.unitPrice.toFixed(2) + ' = $' + item.total.toFixed(2) + '<br>';
                });
            }
            
            html += '<strong>Total:</strong> $' + data.total.toFixed(2) + '<br><br>';
            html += '</div>';
            
            html += '<div class="response-buttons" id="invoiceButtons-' + data.invoiceNumber + '">';
            html += '<button class="action-btn" onclick="confirmInvoice(\'' + data.invoiceNumber + '\')" style="background:#28a745;color:white;">Confirm</button>';
            html += '<button class="action-btn" onclick="cancelInvoice()">Cancel</button>';
            html += '</div>';
            
            return html;
        }
        
        function cancelInvoice() {
            window.pendingInvoiceData = null;
            window.pendingInvoiceWarningShown = false;
            window.pendingMessageAfterWarning = null;
            addMessage('Invoice cancelled.', false);
            setTimeout(() => addFollowUpButtons(), 100);
        }
        
        async function confirmInvoice(invoiceNumber) {
            if (!window.pendingInvoiceData) {
                addMessage('No pending invoice to confirm.', false);
                return;
            }
            
            const data = window.pendingInvoiceData;
            
            try {
                const response = await fetch('/api/invoice/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        invoiceNumber: data.invoiceNumber,
                        date: data.date,
                        total: data.total,
                        items: data.items  // Send items for inventory deduction
                    })
                });
                
                const result = await response.json();
                
                // Handle Google not connected
                if (response.status === 401) {
                    handleGoogleDisconnected();
                    addMessage(`<div style="color: #dc3545;">‚ö†Ô∏è ${result.error || 'Google account not connected.'}</div>
                        <div style="margin-top: 8px;">Please connect your Google account to confirm invoices.</div>
                        <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle('invoice')">Connect Google Account</button>`, false);
                    return;
                }
                
                if (result.success) {
                    // Update buttons to show PDF and Email options
                    const buttonsDiv = document.getElementById('invoiceButtons-' + data.invoiceNumber);
                    if (buttonsDiv) {
                        buttonsDiv.innerHTML = '<span style="color:#28a745;font-weight:bold;">‚úì Confirmed</span>';
                    }
                    
                    // Build confirmation message with inventory updates and action buttons
                    let confirmMsg = 'Invoice ' + data.invoiceNumber + ' confirmed and added to spreadsheet.';
                    if (result.deductions && result.deductions.length > 0) {
                        confirmMsg += '<br><br><strong>Roasted inventory updated:</strong><br>';
                        result.deductions.forEach(d => {
                            confirmMsg += `‚Ä¢ ${d.product}: -${d.deducted} lb (${d.remaining} lb remaining)<br>`;
                        });
                    }
                    
                    // Add action buttons
                    confirmMsg += '<div class="response-buttons" style="margin-top: 12px;">';
                    confirmMsg += '<button class="action-btn" onclick="openEmailModalWithInvoice(\'' + data.pdfUrl + '\', \'' + data.invoiceNumber + '\', \'' + data.customer.replace(/'/g, "\\'") + '\')">Draft Invoice Email</button>';
                    confirmMsg += '<a href="' + data.pdfUrl + '" download="' + data.invoiceNumber + '.pdf" class="action-btn" style="text-decoration:none;">Download PDF</a>';
                    confirmMsg += '<button class="action-btn" onclick="addFollowUpMessage()">Done</button>';
                    confirmMsg += '</div>';
                    
                    addMessage(confirmMsg, false);
                    
                    // Reload inventory to reflect changes
                    await loadInventory();
                    
                    window.pendingInvoiceData = null;
                    window.pendingInvoiceWarningShown = false;
                    window.pendingMessageAfterWarning = null;
                } else {
                    // Handle insufficient inventory with detailed message
                    if (result.error === 'insufficient_inventory' && result.shortages) {
                        let errorHtml = '<strong style="color: #ff6b6b;">Cannot Confirm Invoice</strong><br><br>';
                        errorHtml += '<div style="margin-bottom: 12px;">Not enough roasted coffee in inventory:</div>';
                        result.shortages.forEach(s => {
                            errorHtml += `<div style="color: #ff6b6b; margin-bottom: 4px;">‚Ä¢ ${s.name}: need ${s.required}lb but only <strong>${s.available}lb</strong> available</div>`;
                        });
                        errorHtml += '<br><div>Please reduce the quantity or order more roasted coffee first.</div>';
                        addMessage(errorHtml, false);
                    } else {
                        addMessage('Failed: ' + (result.message || result.error || 'Failed to confirm invoice'), false);
                    }
                }
            } catch (error) {
                console.error('Error confirming invoice:', error);
                addMessage('Error confirming invoice. Please try again.', false);
            }
        }

        // Handle user choosing to proceed without confirming pending invoice
        function proceedWithoutInvoice() {
            const originalMessage = window.pendingMessageAfterWarning;
            window.pendingInvoiceData = null;
            window.pendingInvoiceWarningShown = false;
            window.pendingMessageAfterWarning = null;
            
            addMessage('Invoice discarded.', false);
            
            if (originalMessage) {
                addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
                processMessage(originalMessage).then(response => {
                    const messages = chatContainer.querySelectorAll('.message');
                    messages[messages.length - 1].remove();
                    if (response !== null) addMessage(response, false);
                });
            } else {
                addFollowUpButtons();
            }
        }
        
        // Re-show the pending invoice for user to confirm or edit
        function reshowPendingInvoice() {
            window.pendingInvoiceWarningShown = false;
            window.pendingMessageAfterWarning = null;
            
            if (!window.pendingInvoiceData) {
                addMessage('No pending invoice found.', false);
                return;
            }
            
            const data = window.pendingInvoiceData;
            let html = '<div>';
            html += '<strong>üìã Pending Invoice</strong><br><br>';
            html += '<strong>Invoice #:</strong> ' + data.invoiceNumber + '<br>';
            html += '<strong>Customer:</strong> ' + data.customer + '<br>';
            
            if (data.items && data.items.length > 0) {
                html += '<strong>Items:</strong><br>';
                data.items.forEach(item => {
                    html += '- ' + item.quantity + ' lbs ' + item.description.replace(' (units in lbs)', '') + ' @ $' + item.unitPrice.toFixed(2) + ' = $' + item.total.toFixed(2) + '<br>';
                });
            }
            
            html += '<strong>Total:</strong> $' + data.total.toFixed(2) + '<br><br>';
            html += '<em style="color: #888;">To make changes, generate a new invoice with the correct details.</em><br><br>';
            html += '</div>';
            
            html += '<div class="response-buttons">';
            html += '<button class="action-btn" onclick="confirmInvoice(\'' + data.invoiceNumber + '\')" style="background:#28a745;color:white;">Confirm</button>';
            html += '<button class="action-btn" onclick="cancelInvoice()">Cancel</button>';
            html += '</div>';
            
            addMessage(html, false);
        }
        
        // Discard the pending invoice
        function discardPendingInvoice() {
            window.pendingInvoiceData = null;
            window.pendingInvoiceWarningShown = false;
            window.pendingMessageAfterWarning = null;
            addMessage('Invoice discarded. What else can I help with?', false);
            addFollowUpButtons();
        }

        // Gemini-powered conversational follow-up
        async function addConversationalFollowUp(context) {
            // For unclear requests, just show buttons without another message
            if (context === 'unclear_request') {
                addFollowUpButtons();
                return;
            }
            
            try {
                const response = await fetch('/api/chat/respond', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        completedAction: context,
                        inventory: {
                            green: greenCoffeeInventory,
                            roasted: roastedCoffeeInventory,
                            enRoute: enRouteCoffeeInventory
                        }
                    })
                });
                
                const data = await response.json();
                
                // Add the conversational message with simple button options
                let html = `<div style="margin-bottom: 12px;">${data.message || 'What else can I help with?'}</div>`;
                html += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
                html += '<button class="action-btn" onclick="showToDo()">üìã To Do</button>';
                html += '<button class="action-btn" onclick="checkCurrentInventory()">Check Inventory</button>';
                html += '<button class="action-btn" onclick="openManageInventory()">Manage Inventory</button>';
                html += '<button class="action-btn" onclick="startRoastOrder()">Order Roast</button>';
                html += '<button class="action-btn" onclick="viewEnRoute()">En Route</button>';
                html += '<button class="action-btn" onclick="startInvoice()">Generate Invoice</button>';
                html += '<button class="action-btn" onclick="manageRetailPlaceholder()">Manage Retail</button>';
                html += '<button class="action-btn" onclick="openManageCustomers()">Manage Customers</button>';
                html += '</div>';
                
                addMessage(html, false);
                
            } catch (error) {
                console.error('Error getting follow-up:', error);
                addFollowUpMessage();
            }
        }
        
        function addFollowUpButtons() {
            // Just buttons, no message
            let html = '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
            html += '<button class="action-btn" onclick="showToDo()">üìã To Do</button>';
            html += '<button class="action-btn" onclick="checkCurrentInventory()">Check Inventory</button>';
            html += '<button class="action-btn" onclick="openManageInventory()">Manage Inventory</button>';
            html += '<button class="action-btn" onclick="startRoastOrder()">Order Roast</button>';
            html += '<button class="action-btn" onclick="viewEnRoute()">En Route</button>';
            html += '<button class="action-btn" onclick="startInvoice()">Generate Invoice</button>';
            html += '<button class="action-btn" onclick="manageRetailPlaceholder()">Manage Retail</button>';
            html += '<button class="action-btn" onclick="openManageCustomers()">Manage Customers</button>';
            html += '</div>';
            
            addMessage(html, false);
        }

        function addFollowUpMessage() {
            let html = '<div style="margin-bottom: 12px;">What else can I help with?</div>';
            html += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
            html += '<button class="action-btn" onclick="showToDo()">üìã To Do</button>';
            html += '<button class="action-btn" onclick="checkCurrentInventory()">Check Inventory</button>';
            html += '<button class="action-btn" onclick="openManageInventory()">Manage Inventory</button>';
            html += '<button class="action-btn" onclick="startRoastOrder()">Order Roast</button>';
            html += '<button class="action-btn" onclick="viewEnRoute()">En Route</button>';
            html += '<button class="action-btn" onclick="startInvoice()">Generate Invoice</button>';
            html += '<button class="action-btn" onclick="manageRetailPlaceholder()">Manage Retail</button>';
            html += '<button class="action-btn" onclick="openManageCustomers()">Manage Customers</button>';
            html += '</div>';
            
            addMessage(html, false);
        }
        
        // ============ Retail Sales Management ============
        
        let retailProducts = [];
        let retailWeeks = [];
        let retailMissingWeeks = [];
        let retailIncompleteWeeks = [];
        
        async function manageRetail() {
            addMessage('Loading retail sales data...', false);
            
            try {
                const response = await fetch('/api/retail/data');
                const data = await response.json();
                
                if (response.status === 401) {
                    const messages = chatContainer.querySelectorAll('.message');
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg) {
                        const content = lastMsg.querySelector('.message-content') || lastMsg;
                        content.innerHTML = `<div style="color: #dc3545;">‚ö†Ô∏è Google account not connected.</div>
                            <button class="action-btn" style="margin-top: 12px;" onclick="connectGoogle()">Connect Google Account</button>`;
                    }
                    return;
                }
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                retailProducts = data.products || [];
                retailWeeks = data.weeks || [];
                retailMissingWeeks = data.missingWeeks || [];
                retailIncompleteWeeks = data.incompleteWeeks || [];
                
                // Show retail management UI
                showRetailManagementUI(data);
                
            } catch (error) {
                console.error('Error loading retail data:', error);
                const messages = chatContainer.querySelectorAll('.message');
                const lastMsg = messages[messages.length - 1];
                if (lastMsg) {
                    const content = lastMsg.querySelector('.message-content') || lastMsg;
                    content.innerHTML = `<div style="color: #dc3545;">Error loading retail data: ${error.message}</div>`;
                }
            }
        }
        
        function showRetailManagementUI(data) {
            let html = '<strong>Retail Sales Management</strong><br><br>';
            
            // Current products
            html += '<div style="margin-bottom: 16px;">';
            html += '<strong>Products:</strong> ';
            if (retailProducts.length > 0) {
                html += retailProducts.map(p => p.name).join(', ');
            } else {
                html += 'No products found';
            }
            html += '</div>';
            
            // Missing weeks alert
            if (retailMissingWeeks.length > 0) {
                html += `<div style="background: #3a3a20; padding: 10px; border-radius: 8px; margin-bottom: 12px;">`;
                html += `<strong>üìÖ ${retailMissingWeeks.length} new week(s) to add:</strong><br>`;
                html += retailMissingWeeks.join(', ');
                html += `<br><button class="action-btn" style="margin-top: 8px;" onclick="addMissingRetailWeeks()">Add Missing Weeks</button>`;
                html += `</div>`;
            }
            
            // Incomplete weeks
            if (retailIncompleteWeeks.length > 0) {
                html += `<div style="background: #3a2020; padding: 10px; border-radius: 8px; margin-bottom: 12px;">`;
                html += `<strong>‚ö†Ô∏è ${retailIncompleteWeeks.length} week(s) need sales data:</strong><br>`;
                retailIncompleteWeeks.slice(0, 5).forEach(week => {
                    html += `<div style="margin: 8px 0;">`;
                    html += `<span style="font-weight: bold;">${week.dateRange}</span> `;
                    html += `<button class="action-btn" style="padding: 4px 8px; font-size: 11px;" onclick="enterWeekSales(${week.rowIndex}, '${week.dateRange}')">Enter Sales</button>`;
                    html += `</div>`;
                });
                if (retailIncompleteWeeks.length > 5) {
                    html += `<div style="color: #888; font-size: 11px;">...and ${retailIncompleteWeeks.length - 5} more</div>`;
                }
                html += `</div>`;
            }
            
            // Recent weeks with data
            const weeksWithData = retailWeeks.filter(w => w.hasData).slice(-3).reverse();
            if (weeksWithData.length > 0) {
                html += `<div style="margin-bottom: 12px;">`;
                html += `<strong>Recent Sales:</strong><br>`;
                weeksWithData.forEach(week => {
                    html += `<div style="margin: 4px 0; font-size: 12px;">`;
                    html += `${week.dateRange}: $${week.totalSales?.toFixed(2) || '0.00'} (net: $${week.netPayout?.toFixed(2) || '0.00'})`;
                    html += `</div>`;
                });
                html += `</div>`;
            }
            
            // Action buttons
            html += '<div class="response-buttons" style="margin-top: 12px;">';
            html += '<button class="action-btn" onclick="showRetailProductsManager()">Manage Products</button>';
            html += '<button class="action-btn" onclick="showRecentRetailWeeks()">Recent Sales Weeks</button>';
            html += '<button class="action-btn" onclick="cancelRetailMode()">Done</button>';
            html += '</div>';
            
            const messages = chatContainer.querySelectorAll('.message');
            const lastMsg = messages[messages.length - 1];
            if (lastMsg) {
                const content = lastMsg.querySelector('.message-content') || lastMsg;
                content.innerHTML = html;
            }
        }
        
        async function addMissingRetailWeeks() {
            if (retailMissingWeeks.length === 0) return;
            
            addMessage('Adding missing weeks...', false);
            
            try {
                const response = await fetch('/api/retail/add-weeks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ weeks: retailMissingWeeks })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reload retail data
                    await manageRetail();
                } else {
                    throw new Error(data.error || 'Failed to add weeks');
                }
                
            } catch (error) {
                console.error('Error adding weeks:', error);
                addMessage(`Error: ${error.message}`, false);
            }
        }
        
        function enterWeekSales(rowIndex, dateRange) {
            let html = `<strong>Enter Sales for ${dateRange}</strong><br><br>`;
            html += '<div style="margin-bottom: 12px;">';
            
            retailProducts.forEach(product => {
                html += `<div style="margin: 8px 0; display: flex; align-items: center; gap: 8px;">`;
                html += `<label style="min-width: 150px;">${product.name}:</label>`;
                html += `<input type="number" step="0.01" min="0" id="retail-${product.index}" 
                         style="width: 80px; padding: 6px; background: #2a2a2a; border: 1px solid #404040; color: #fff; border-radius: 4px;"
                         placeholder="0.00">`;
                html += `</div>`;
            });
            
            html += '</div>';
            html += '<div class="response-buttons">';
            html += `<button class="action-btn" onclick="saveWeekSales(${rowIndex}, '${dateRange}')">Save</button>`;
            html += '<button class="action-btn" onclick="manageRetail()">Cancel</button>';
            html += '</div>';
            
            addMessage(html, false);
        }
        
        async function saveWeekSales(rowIndex, dateRange) {
            const sales = {};
            
            retailProducts.forEach(product => {
                const input = document.getElementById(`retail-${product.index}`);
                if (input && input.value) {
                    sales[product.name] = parseFloat(input.value);
                }
            });
            
            if (Object.keys(sales).length === 0) {
                addMessage('Please enter at least one sales value.', false);
                return;
            }
            
            addMessage('Saving sales data...', false);
            
            try {
                const response = await fetch('/api/retail/sales', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rowIndex, sales })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage(`Sales for ${dateRange} saved successfully!`, false);
                    setTimeout(() => manageRetail(), 1000);
                } else {
                    throw new Error(data.error || 'Failed to save sales');
                }
                
            } catch (error) {
                console.error('Error saving sales:', error);
                addMessage(`Error: ${error.message}`, false);
            }
        }
        
        function showRecentRetailWeeks() {
            let html = '<strong>Recent Sales Weeks</strong><br><br>';
            
            if (retailWeeks.length === 0) {
                html += 'No weeks found.';
            } else {
                html += '<div style="max-height: 300px; overflow-y: auto;">';
                // Show only the 3 most recent weeks
                retailWeeks.slice().reverse().slice(0, 3).forEach(week => {
                    const status = week.hasData ? '‚úì' : '‚óã';
                    const statusColor = week.hasData ? '#28a745' : '#888';
                    html += `<div style="margin: 6px 0; display: flex; align-items: center; gap: 8px;">`;
                    html += `<span style="color: ${statusColor};">${status}</span>`;
                    html += `<span style="min-width: 100px;">${week.dateRange}</span>`;
                    if (week.hasData) {
                        html += `<span style="color: #888;">$${week.totalSales?.toFixed(2) || '0.00'}</span>`;
                    }
                    html += `<button class="action-btn" style="padding: 2px 6px; font-size: 10px;" 
                             onclick="enterWeekSales(${week.rowIndex}, '${week.dateRange}')">${week.hasData ? 'Edit' : 'Enter'}</button>`;
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            html += '<div class="response-buttons" style="margin-top: 12px;">';
            html += '<button class="action-btn" onclick="manageRetail()">Back</button>';
            html += '</div>';
            
            addMessage(html, false);
        }
        
        function showRetailProductsManager() {
            let html = '<strong>Manage Retail Products</strong><br><br>';
            
            html += '<div style="margin-bottom: 16px;">';
            html += '<strong>Current Products:</strong><br>';
            
            if (retailProducts.length === 0) {
                html += '<div style="color: #888;">No products configured</div>';
            } else {
                retailProducts.forEach(product => {
                    html += `<div style="margin: 6px 0; display: flex; align-items: center; gap: 8px;">`;
                    html += `<span style="min-width: 150px;">${product.name}</span>`;
                    html += `<button class="action-btn" style="padding: 2px 6px; font-size: 10px;" 
                             onclick="renameRetailProduct('${product.name}')">Rename</button>`;
                    html += `<button class="action-btn" style="padding: 2px 6px; font-size: 10px; background: #4a3030;" 
                             onclick="removeRetailProduct('${product.name}')">Remove</button>`;
                    html += `</div>`;
                });
            }
            html += '</div>';
            
            // Add new product
            html += '<div style="margin-bottom: 12px;">';
            html += '<strong>Add New Product:</strong><br>';
            html += `<div style="display: flex; gap: 8px; margin-top: 8px;">`;
            html += `<input type="text" id="new-retail-product" placeholder="Product name (e.g., Colombia (S))"
                     style="flex: 1; padding: 8px; background: #2a2a2a; border: 1px solid #404040; color: #fff; border-radius: 4px;">`;
            html += `<button class="action-btn" onclick="addRetailProduct()">Add</button>`;
            html += `</div>`;
            html += '</div>';
            
            html += '<div class="response-buttons" style="margin-top: 12px;">';
            html += '<button class="action-btn" onclick="manageRetail()">Back</button>';
            html += '</div>';
            
            addMessage(html, false);
        }
        
        async function addRetailProduct() {
            const input = document.getElementById('new-retail-product');
            const productName = input?.value?.trim();
            
            if (!productName) {
                alert('Please enter a product name');
                return;
            }
            
            addMessage(`Adding product "${productName}"...`, false);
            
            try {
                const response = await fetch('/api/retail/products/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ productName })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage(`Product "${productName}" added!`, false);
                    setTimeout(() => manageRetail(), 1000);
                } else {
                    throw new Error(data.error || 'Failed to add product');
                }
                
            } catch (error) {
                console.error('Error adding product:', error);
                addMessage(`Error: ${error.message}`, false);
            }
        }
        
        async function removeRetailProduct(productName) {
            if (!confirm(`Remove "${productName}"? This will delete all sales data for this product.`)) {
                return;
            }
            
            addMessage(`Removing product "${productName}"...`, false);
            
            try {
                const response = await fetch('/api/retail/products/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ productName })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addMessage(`Product "${productName}" removed.`, false);
                    setTimeout(() => manageRetail(), 1000);
                } else {
                    throw new Error(data.error || 'Failed to remove product');
                }
                
            } catch (error) {
                console.error('Error removing product:', error);
                addMessage(`Error: ${error.message}`, false);
            }
        }
        
        function renameRetailProduct(oldName) {
            const newName = prompt(`Rename "${oldName}" to:`, oldName);
            if (!newName || newName === oldName) return;
            
            addMessage(`Renaming "${oldName}" to "${newName}"...`, false);
            
            fetch('/api/retail/products/rename', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ oldName, newName })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    addMessage(`Renamed to "${newName}"!`, false);
                    setTimeout(() => manageRetail(), 1000);
                } else {
                    throw new Error(data.error);
                }
            })
            .catch(error => {
                console.error('Error renaming product:', error);
                addMessage(`Error: ${error.message}`, false);
            });
        }
        
        function cancelRetailMode() {
            addMessage('Retail management closed.', false);
            addFollowUpMessage();
        }
        
        // Alias for backward compatibility
        function manageRetailPlaceholder() {
            manageRetail();
        }

        function useQuickAction(prompt) {
            addMessage(prompt, true);
            
            addMessage('<div class="loader" style="width:24px;height:24px;border:2px solid #404040;border-top-color:#28a745;border-radius:50%;animation:spin 1s linear infinite;"></div>', false);
            
            processMessage(prompt).then(response => {
                const messages = chatContainer.querySelectorAll('.message');
                messages[messages.length - 1].remove();
                if (response !== null) addMessage(response, false);
            });
        }

        function openEmailModalWithInvoice(pdfUrl, invoiceNumber, customerName) {
            if (!googleConnected) {
                alert('Please connect Google first.');
                return;
            }
            
            // Store invoice info for later
            const modal = document.getElementById('emailModal');
            modal.dataset.pdfUrl = pdfUrl;
            modal.dataset.invoiceNumber = invoiceNumber;
            modal.dataset.customerName = customerName;
            
            // Fetch customer emails
            fetch('/api/customers/' + encodeURIComponent(customerName))
                .then(response => response.json())
                .then(data => {
                    if (data.emails && data.emails.length > 0) {
                        // Store original emails for comparison
                        modal.dataset.originalEmails = data.emails.join(', ');
                        // Auto-populate with customer emails
                        document.getElementById('emailTo').value = data.emails.join(', ');
                        showEmailModal(invoiceNumber);
                    } else {
                        modal.dataset.originalEmails = '';
                        // No emails on file - prompt for email
                        promptForCustomerEmail(customerName, invoiceNumber);
                    }
                })
                .catch(error => {
                    console.error('Error fetching customer:', error);
                    modal.dataset.originalEmails = '';
                    // Customer not found - prompt for email
                    promptForCustomerEmail(customerName, invoiceNumber);
                });
        }
        
        function promptForCustomerEmail(customerName, invoiceNumber) {
            // Ask user for email in chat
            addMessage(`What is the email for ${customerName}? (You can enter multiple emails separated by "and" or commas)`, false);
            
            // Set state to wait for email input
            window.waitingForCustomerEmail = true;
            window.pendingEmailInvoice = { customerName, invoiceNumber };
        }
        
        async function processCustomerEmail(emailInput) {
            const pending = window.pendingEmailInvoice;
            if (!pending) return;
            
            window.waitingForCustomerEmail = false;
            
            // Send to backend to parse and save emails
            try {
                const response = await fetch('/api/customers/emails', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customerName: pending.customerName,
                        emailsInput: emailInput
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.emails) {
                    addMessage(`Saved email(s) for ${pending.customerName}: ${data.emails.join(', ')}`, false);
                    
                    // Now open the email modal with the emails
                    document.getElementById('emailTo').value = data.emails.join(', ');
                    showEmailModal(pending.invoiceNumber);
                } else {
                    addMessage(`${data.error || 'Could not process email. Please try again.'}`, false);
                }
            } catch (error) {
                console.error('Error saving email:', error);
                addMessage('Error saving email. Please try again.', false);
            }
            
            window.pendingEmailInvoice = null;
        }
        
        function showEmailModal(invoiceNumber) {
            document.getElementById('emailSubject').value = 'Invoice ' + invoiceNumber + ' - Archives of Us Coffee';
            document.getElementById('emailBody').value = `Hello,
Please find attached invoice ${invoiceNumber}.

If you have any questions about this invoice, please don't hesitate to reach out.

Best,
Archives of Us Coffee`;
            
            // Show attachment indicator
            document.getElementById('attachmentIndicator').style.display = 'block';
            document.getElementById('attachmentName').textContent = invoiceNumber + '.pdf';
            
            document.getElementById('emailModal').classList.add('active');
        }

        sendBtn.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Close modal on overlay click
        document.getElementById('emailModal').addEventListener('click', function(e) {
            if (e.target === this) closeEmailModal();
        });

        // Close modal on Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeEmailModal();
        });

        // Detect microphone
        navigator.mediaDevices.enumerateDevices().then(devices => {
            const hasAudio = devices.some(d => d.kind === 'audioinput');
            if (hasAudio) {
                micIndicator.classList.add('connected');
                micStatus.textContent = 'Microphone ready';
            }
        });
    </script>
</body>
</html>